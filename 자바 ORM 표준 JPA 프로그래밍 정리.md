# 들어가며 (26 ~ 28페이지) : 이 책을 왜 썼는지, 읽는 데 어떤 것들이 필요한지 나와있어서 정리함

JPA를 이해하려면 아래 목록에 있는 기술에 대한 기초적인 이해가 필요하다.
 자바 언어와 JDBC를 사용한 데이터베이스 프로그래밍, 그리고 객체지향 프로그래밍과 관계형 데이터베이스에 대한 
A. JAVA
B. JDBC를 사용한 데이터베이스 프로그래밍
C. 객체지향 프로그래밍
D. 관계형 데이터베이스
E. 웹 개발과 스프링 프레임워크
F. JUnit
G. 메이븐

JPA는 크게 객체와 테이블을 매핑하는 설계, 그리고 설계한 모델을 사용하는 부분으로 나뉜다.

1~9장은 이론 편이다. 이론에 대해서 집중적으로 공부할 것 같다.

JPA를 사용하면 개발 생산성과 유지보수가 좋아지고 코드 품질과 테스트에 더 많은 시간을 할애할 수 있다.

==========================================================1장 : JPA 소개

JDBC와 마이바티스(MyBatis), JdbcTemplate를 함께 사용해도, 기본적인 CRUD용 SQL은 반복해서 작성해야 했다. 이는 매우 비생산적이고 확장성이 부족했다.

이를 해결하기 위한 것은 객체 모델링이었으나, SQL만으로는 객체 모델링에 많은 어려움이 따랐다.

이러한 객체-데이터베이스 간 차이를 메워주는 것이 ORM(Object Relational Mapping)이다. JPA는 ORM의 자바 버전이라고 생각하자.

JPA는 반복적인 CRUD SQL을 처리해주며 조회 결과를 객체로 자동으로 매핑해준다. 또한 데이터베이스를 변경할 때 코드 수정이 간편하다.

# SQL을 직접 다룰 때 발생하는 문제점 (32페이지 ~ 39페이지)

자바로 개발하는 애플리케이션은 대부분 관계형 데이터베이스를 사용하고, 이 경우 JDBC를 통해 SQL을 다룬다.

이 경우 자바-DB 간 상호작용은 다음과 같이 이루어질 것이다.

A. 데이터 조회에 필요한 SQL을 작성한다.
B. JDBC를 사용해서 SQL을 실행시킨다.
C. 조회 결과를 자바 클래스 객체로 매핑한다.

위 결과를 거쳐 조회한 자바 클래스 객체를 자바 컬렉션에 보관할 경우, 개발자는 SQL과 JDBC를 사용해 데이터를 객체로 변환하는 작업을 반드시 거쳐야 한다.

이러한 CRUD를 진행하려면 SQL과 JDBC API를 반복해야 한다.

위 과정에서 데이터 사양이 하나 추가될 경우 클래스, CRUD SQL, JDBC 객체를 모두 수정해야 한다.

또한 자바 단의 DAO에서 어떤 SQL을 사용하고 있는지 하나하나 확인해야 된다. 즉, 엔티티(비즈니스 요구사항을 위해 만들어진 객체)와의 의존관계가 너무나 강해진다.

위 상황에서 JPA를 사용할 경우, CRUD 과정에서 개발자가 직접 SQL을 작성하지 않고 JPA의 API를 활용하게 된다.

# 패러다임의 불일치 (40 ~ 53 페이지)

현대의 복잡한 애플리케이션은 대부분 객체지향 언어로 개발되고 있다.

자바에서 이렇게 다루고 있는 객체들을 데이터베이스에 저장해야 하는데, 데이터베이스에는 자바에서 다루는 객체지향적 기술이나 개념이 없다.

이는 애초에 자바와 관계형DB가 지향하는 목적이 서로 다르기 때문이다. 이를 패러다임 불일치 문제라고 한다.

이 둘의 불일치 문제는 개발자가 해결해야 하는데, 이 과정에서 많은 시간과 코드를 소비하게 된다.

예시) 자바의 상속 클래스 관계는 DB에서 온전히 구현되지 못해, 부모와 자식 클래스에 해당하는 두 테이블의 데이터를 따로따로 다루고 합쳐야만 한다.

## 이 경우 JPA를 사용하면 자바에서 상속된 클래스를 다루면 내부적으로 쿼리를 생성해 준다.

자바에서는 다른 객체와 연관관계를 가질 때 참조를 사용한다. 반면 테이블(DB)은 외래키를 사용해 연관관계를 만들고 조인을 사용해 조회한다.

이러한 차이 때문에 객체 쪽에서 DB에 맞춰 모양을 바꾸면 객체지향이 사라지고, 객체지향을 살릴 경우 DB에 저장하거나 조회하기가 어려워지는 이지선다에 걸린다.

## 이 경우 JPA를 사용하면 자바 객체에서 설정한 결과를 SQL로 변환해 준다. DB에서 다루는 외래키를 참조 관계로 변환하는 것 또한 처리해 준다.

또한, SQL을 직접 다룰 경우 SQL로의 의존성이 너무 커져 객체로 변환시킨 데이터를 어디까지 조회할 수 있는지 SQL을 직접 확인해야만 알 수 있다.

그렇다고 데이터베이스의 모든 데이터를 객체로 만들어 메모리에 올려두는 것은 현실성이 없으므로, 필요한 데이터만 뽑는 메소드를 수없이 만들어 사용해야 한다.

## 이 경우 JPA를 사용하면 지연 로딩 기능을 통해 데이터를 한번에 조회할지, 실제로 필요한 지점에 필요한 데이터만 조회할지 자유롭게 선택할 수 있다.

객체와 DB에서의 값 비교 방법에서도 차이가 있다. DB는 각 행의 키 값으로 구분하지만, 객체의 경우 ==(주소값 확인), .equals(들어간 값 확인)로 구분한다.

이때문에 DB에서 조회한 같은 데이터를 같은 인스턴스로(같은 주소값을 가진 객체로) 반환하는 것 또한 쉽지 않다.

## 이 경우 JPA를 사용하면 같은 트랜잭션일 때 같은 객체로 조회되는 것을 보장해 준다(한 번의 코드로 조회한 데이터라면, 주소값이 같은 객체로 반환해 준다.)

# JPA란 무엇인가? (54 ~ 59 페이지) 진행 중

JPA는 애플리케이션과 JDBC 사이에서 동작하는 ORM이다. ORM은 객체와 관계형 데이터베이스를 매핑해준다.

ORM의 장점은 객체와 DB를 자연스럽게 이어줌과 동시에 패러다임 불일치를 자동으로 해결해 준다는 것이다. 자바는 자바스럽게(객체지향에 맞게) 코딩하면 되고, DB는 DB스럽게 만들면 된다.

이러한 ORM 프레임워크로 많이 사용되는 것이 하이버네이트이다.

JPA의 장점을 정리하자면 아래와 같다.

A. 자바에서 객체를 다루는 것과 같이 JPA를 이용하면 CRUD SQL 작성과 JDBC API를 쓰는 과정이 자동으로 처리되어 생산성이 올라간다.
B. 엔티티(객체)에 필드를 추가하기만 하면 자동으로 관련 SQL, JDBC를 자동으로 수정해줘 유지보수가 간편해진다.
C. 패러다임 불일치 문제를 자동으로 처리해주어 개발자의 수고를 덜 수 있다.
D. 데이터베이스와의 통신 등에서 내부적으로 최적화를 진행하여 성능 면에서 우수하다.
E. 다른 데이터베이스를 사용하게 되어도 JPA를 거치면 변경이 수월하다.

# ORM에 대한 궁금증과 오해 (60 ~ 62 페이지). 별다른 내용 없어서 패스. 중요한 건 ORM은 객체지향과 관계형데이터베이스를 전제로 한 기술이라는 것.

===================================================2장 : JPA 시작(64 ~ 88페이지) - 설치 및 환경 설정 관련이므로 패스. 

===================================================3장 : 영속성 관리

# 엔티티 매니저 팩토리와 엔티티 매니저(90 ~ 91 페이지) 진행 중

JPA에서 엔티티와 테이블을 매핑한다고 했다. 이렇게 매핑된 엔티티를 실제 사용하는 데 엔티티 매니저를 거쳐야 한다.

엔티티 매니저는 엔티티를 저장/수정/삭제/조회하는 등 엔티티와 관련된 모든 일을 처리한다.

엔티티 매니저는 가상의 데이터베이스라고 생각하면 된다. 엔티티 매니저를 생성하려면 먼저 엔티티 매니저 팩토리를 생성해야 한다.

DB를 하나 쓰는 애플리케이션은 보통 EntityManagerFactory를 하나 생성한다. 

```
EntityManagerFactory emf = Persistence.createEntityManagerFactory("팩토리이름"); << 엔티티 매니저 팩토리 생성. 비용이 많이 든다고 함
EntityManager em = emf.createEntityManager(); << 엔티티 매니저 생성. 비용 거의 안 든다고 함
```

엔티티 매니저 팩토리에는 여러 스레드가 동시에 접근해도 되지만, 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 공유해선 안 된다.

EntityManagerFactory를 생성하면 보통 커넥션풀도 같이 생성한다.

# 영속성 컨테스트란? (92페이지)

JPA를 이해하는 데 가장 중요한 용어는 영속성 컨텍스트다. 이는 '엔티티를 영구 저장하는 환경' 을 말하며, 엔티티 매니저를 이용할 때 같이 사용된다.

영속성 컨테스트는 논리적인 개념에 가까우며 엔티티 매니저를 생성할 때 하나 만들어진다.

# 엔티티의 생명주기 (92 ~ 94 페이지)

엔티티에는 4가지 상태가 존재한다.

```
A. 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태
B. 영속 : 영속성 컨텍스트에 저장된 상태
C. 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
D. 삭제 : 삭제된 상태
```

비영속 상태는 엔티티 객체를 생성했지만 저장하지는 않은 상태로, 이 때 엔티티는 영속성 컨텍스트나 DB와는 전혀 관련이 없다.

영속 상태는 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장한 상태다. 이 때부터 엔티티는 영속성 컨텍스트를 통해 관리하게 된다. 또한 조회 중인 엔티티도 영속 상태이다.

준영속 상태는 영속 상태이던 엔티티를 영속성 컨텍스트가 관리하지 않게 되는 상태이다. 영속성 컨텍스트를 닫거나 초기화해도 그 엔티티는 준영속 상태가 된다.

삭제 상태는 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한 상태이다.

# 영속성 컨텍스트의 특징 (95 ~ 페이지) 진행 중

영속성 컨텍스트는 엔티티를 식별자 값(@Id를 통해 테이블의 기본 키와 매핑한 값) 으로 구분한다.

즉, 영속 상태의 엔티티는 반드시 식별자 값을 가지게 된다. 식별자 값이 없다면 예외가 발생한다.

영속성 컨텍스트에 저장된 엔티티는 트랜잭션이 커밋되는 순간 해당 엔티티를 DB에 반영한다. 이를 플러시(Flush)라 한다.

영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이를 1차 캐시라고 한다. 영속 상태의 엔티티는 모두 여기에 저장되며, Map 형식으로 @Id-엔티티 객체 형식으로 연결되어 있다.

1차 캐시에 들어간 상태의 엔티티는 아직 데이터베이스에 저장되지 않으며, 이곳에 데이터를 저장하고 조회하는 모든 기준은 데이터베이스의 기본 키 값과 연결되어 있는 식별자 값이다.

데이터를 조회하는 .find() 메소드는 호출 시 먼저 1차 캐시에서 엔티티를 찾아보고, 있다면 데이터베이스 조회 없이 불러와 사용한다. 만약 없다면 DB를 찾아가 조회한다.

영속성 컨텍스트 단에서 불러온 객체는 1차 캐시에서 불러온 같은 객체임으로 객체 동일성을 보장한다.

JPA는 트랜잭션이 커밋되는 순간 데이터베이스에 SQL을 쏘며, 그 이전까지는 컨텍스트 안에만 있는 상태이다.

엔티티 매니저는 트랜잭션 커밋 전까지 내부 쿼리 저장소에 쿼리들을 모아두었다 커밋 때 적용한다. 이를 쓰기 지연이라고 한다. 쿼리를 한 번에 전달하므로써 성능을 최적화할 수 있다고 한다.

SQL로 데이터를 수정하려면 수정 쿼리를 직접 작성해야 한다. 이는 비즈니스 로직이 SQL에 계속해서 의존해야만 하는(로직 돌아가는 걸 확인하려면 자꾸 쿼리문을 확인해야만 하는) 문제점을 낳는다.

JPA에서는 엔티티의 변경사항이 생겼을 경우, 해당 엔티티의 데이터를 변경만 해두면 DB에 자동으로 반영이 된다. 이를 변경 감지 기능이라고 한다.

변경 감지 기능은 영속성 컨텍스트에 보관할 때의 엔티티 데이터와, 플러시 시점(커밋 시점)의 엔티티 데이터를 비교하여 변경된 데이터를 플러시 시점에 UPDATE 시켜준다.

변경 감지 기능은 영속성 컨텍스트가 관리 중인 엔티티(즉 영속 상태)에만 적용된다. 비영속이나 준영속 상태의 엔티티에는 적용되지 않는다.

변경 감지 적용 시, 변경할 데이터만 UPDATE하지 않고 엔티티의 모든 필드를 UPDATE한다. 이는 쿼리의 재사용성(쿼리문 스타일 조회한 같은 데이터를 같은 인스턴스로(같은 주소값을 가진 객체로) 반환하는 것 또한 쉽지 않다.

## 이 경우 JPA를 사용하면 같은 트랜잭션일 때 같은 객체로 조회되는 것을 보장해 준다(한 번의 코드로 조회한 데이터라면, 주소값이 같은 객체로 반환해 준다.)

# JPA란 무엇인가? (54 ~ 59 페이지) 진행 중

JPA는 애플리케이션과 JDBC 사이에서 동작하는 ORM이다. ORM은 객체와 관계형 데이터베이스를 매핑해준다.

ORM의 장점은 객체와 DB를 자연스럽게 이어줌과 동시에 패러다임 불일치를 자동으로 해결해 준다는 것이다. 자바는 자바스럽게(객체지향에 맞게) 코딩하면 되고, DB는 DB스럽게 만들면 된다.

이러한 ORM 프레임워크로 많이 사용되는 것이 하이버네이트이다.

JPA의 장점을 정리하자면 아래와 같다.

A. 자바에서 객체를 다루는 것과 같이 JPA를 이용하면 CRUD SQL 작성과 JDBC API를 쓰는 과정이 자동으로 처리되어 생산성이 올라간다.
B. 엔티티(객체)에 필드를 추가하기만 하면 자동으로 관련 SQL, JDBC를 자동으로 수정해줘 유지보수가 간편해진다.
C. 패러다임 불일치 문제를 자동으로 처리해주어 개발자의 수고를 덜 수 있다.
D. 데이터베이스와의 통신 등에서 내부적으로 최적화를 진행하여 성능 면에서 우수하다.
E. 다른 데이터베이스를 사용하게 되어도 JPA를 거치면 변경이 수월하다.

# ORM에 대한 궁금증과 오해 (60 ~ 62 페이지). 별다른 내용 없어서 패스. 중요한 건 ORM은 객체지향과 관계형데이터베이스를 전제로 한 기술이라는 것.

===================================================2장 : JPA 시작(64 ~ 88페이지) - 설치 및 환경 설정 관련이므로 패스. 

===================================================3장 : 영속성 관리

# 엔티티 매니저 팩토리와 엔티티 매니저(90 ~ 91 페이지) 진행 중

JPA에서 엔티티와 테이블을 매핑한다고 했다. 이렇게 매핑된 엔티티를 실제 사용하는 데 엔티티 매니저를 거쳐야 한다.

엔티티 매니저는 엔티티를 저장/수정/삭제/조회하는 등 엔티티와 관련된 모든 일을 처리한다.

엔티티 매니저는 가상의 데이터베이스라고 생각하면 된다. 엔티티 매니저를 생성하려면 먼저 엔티티 매니저 팩토리를 생성해야 한다.

DB를 하나 쓰는 애플리케이션은 보통 EntityManagerFactory를 하나 생성한다. 

```
EntityManagerFactory emf = Persistence.createEntityManagerFactory("팩토리이름"); << 엔티티 매니저 팩토리 생성. 비용이 많이 든다고 함
EntityManager em = emf.createEntityManager(); << 엔티티 매니저 생성. 비용 거의 안 든다고 함
```

엔티티 매니저 팩토리에는 여러 스레드가 동시에 접근해도 되지만, 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 공유해선 안 된다.

EntityManagerFactory를 생성하면 보통 커넥션풀도 같이 생성한다.

# 영속성 컨테스트란? (92페이지)

JPA를 이해하는 데 가장 중요한 용어는 영속성 컨텍스트다. 이는 '엔티티를 영구 저장하는 환경' 을 말하며, 엔티티 매니저를 이용할 때 같이 사용된다.

영속성 컨테스트는 논리적인 개념에 가까우며 엔티티 매니저를 생성할 때 하나 만들어진다.

# 엔티티의 생명주기 (92 ~ 94 페이지)

엔티티에는 4가지 상태가 존재한다.

```
A. 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태
B. 영속 : 영속성 컨텍스트에 저장된 상태
C. 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
D. 삭제 : 삭제된 상태
```

비영속 상태는 엔티티 객체를 생성했지만 저장하지는 않은 상태로, 이 때 엔티티는 영속성 컨텍스트나 DB와는 전혀 관련이 없다.

영속 상태는 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장한 상태다. 이 때부터 엔티티는 영속성 컨텍스트를 통해 관리하게 된다. 또한 조회 중인 엔티티도 영속 상태이다.

준영속 상태는 영속 상태이던 엔티티를 영속성 컨텍스트가 관리하지 않게 되는 상태이다. 영속성 컨텍스트를 닫거나 초기화해도 그 엔티티는 준영속 상태가 된다.

삭제 상태는 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한 상태이다.

# 영속성 컨텍스트의 특징 (95 ~ 106 페이지) 진행 중

영속성 컨텍스트는 엔티티를 식별자 값(@Id를 통해 테이블의 기본 키와 매핑한 값) 으로 구분한다.

즉, 영속 상태의 엔티티는 반드시 식별자 값을 가지게 된다. 식별자 값이 없다면 예외가 발생한다.

영속성 컨텍스트에 저장된 엔티티는 트랜잭션이 커밋되는 순간 해당 엔티티를 DB에 반영한다. 이를 플러시(Flush)라 한다.

영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이를 1차 캐시라고 한다. 영속 상태의 엔티티는 모두 여기에 저장되며, Map 형식으로 @Id-엔티티 객체 형식으로 연결되어 있다.

1차 캐시에 들어간 상태의 엔티티는 아직 데이터베이스에 저장되지 않으며, 이곳에 데이터를 저장하고 조회하는 모든 기준은 데이터베이스의 기본 키 값과 연결되어 있는 식별자 값이다.

데이터를 조회하는 .find() 메소드는 호출 시 먼저 1차 캐시에서 엔티티를 찾아보고, 있다면 데이터베이스 조회 없이 불러와 사용한다. 만약 없다면 DB를 찾아가 조회한다.

영속성 컨텍스트 단에서 불러온 객체는 1차 캐시에서 불러온 같은 객체임으로 객체 동일성을 보장한다.

JPA는 트랜잭션이 커밋되는 순간 데이터베이스에 SQL을 쏘며, 그 이전까지는 컨텍스트 안에만 있는 상태이다.

엔티티 매니저는 트랜잭션 커밋 전까지 내부 쿼리 저장소에 쿼리들을 모아두었다 커밋 때 적용한다. 이를 쓰기 지연이라고 한다. 쿼리를 한 번에 전달하므로써 성능을 최적화할 수 있다고 한다.

SQL로 데이터를 수정하려면 수정 쿼리를 직접 작성해야 한다. 이는 비즈니스 로직이 SQL에 계속해서 의존해야만 하는(로직 돌아가는 걸 확인하려면 자꾸 쿼리문을 확인해야만 하는) 문제점을 낳는다.

JPA에서는 엔티티의 변경사항이 생겼을 경우, 해당 엔티티의 데이터를 변경만 해두면 DB에 자동으로 반영이 된다. 이를 변경 감지 기능이라고 한다.

변경 감지 기능은 영속성 컨텍스트에 보관할 때의 엔티티 데이터와, 플러시 시점(커밋 시점)의 엔티티 데이터를 비교하여 변경된 데이터를 플러시 시점에 UPDATE 시켜준다.

변경 감지 기능은 영속성 컨텍스트가 관리 중인 엔티티(즉 영속 상태)에만 적용된다. 비영속이나 준영속 상태의 엔티티에는 적용되지 않는다.

변경 감지 적용 시, 변경할 데이터만 UPDATE하지 않고 엔티티의 모든 필드를 UPDATE한다. 이는 쿼리의 재사용성(쿼리문 스타일이 동일하므로)을 고려한 것이다.

확장 기능을 사용하면 동적으로 UPDATE하는 쿼리도 생성할 수 있다. @org.hibernate.annotations.DynamicUpdate 어노테이션 나중에 찾아보자.

엔티티를 삭제하는 .remove() 메소드를 사용하면 여태까지와 비슷하게 1차 캐시에 쿼리를 두었다가 플러시 시점에 적용시킨다. 엔티티는 메소드 호출 즉시 영속성 컨텍스트에서 제거된다.

# 플러시 (107 ~ 108 페이지) 진행 중

플러시는 영속성 컨텍스트에 저장된 각종 쿼리 및 변경 사항을 DB에 반영하는 단계이다.

플러시 시 변경 감지를 동작해 영속성 컨텍스트 내의 모든 엔티티를 스냅샷(컨텍스트 들어올 때의 엔티티 데이터 최초 상태)과 비교해 수정된 엔티티를 찾고, 그 후 쓰기 지연 SQL 저장소에 쿼리를 등록하고 전송한다.

영속성 컨텍스트를 플러시하는 방법은 아래 3가지이다.

```
A. em.flush()를 호출한다. JPA와 다른 프레임워크를 함꼐 사용하는 경우가 아니면 거의 사용되지 않는다고 한다.
B. 트랜잭션 커밋 시 자동으로 호출된다. JPA는 트랜잭션을 커밋할 경우 데이터베이스로의 반영을 위해 자동으로 플러시를 호출시킨다.
C. JPQL 쿼리 실행 시 자동으로 호출된다. 객체지향 쿼리를 호출할 경우 플러시가 자동으로 실행된다. 이는 쿼리 호출 떄 데이터베이스에 컨텍스트 변경이 반영되어 있어야 하기 때문이다.
```

** 식별자를 기준으로 데이터를 조회하는 find() 메소드를 호출할 때에는 플러시가 실행되지 않는다. 즉 컨텍스트 단계에만 있는 데이터들은 find로 조회할 수 없다.

엔티티 매니저를 통해 플러시 옵션을 지정할 수 있다. javax.persistence.FlushModeType 객체에 대해 한번 조사해 보자. 기본은 커밋이나 쿼리를 실행할 때 플러시한다.

** 플러시 시, 영속성 컨텍스트에 보관된 엔티티는 삭제되지 않는다.

# 준영속 (109 ~ 118페이지)

영속성 컨텍스트에서 관리하는 엔티티가 컨텍스트에서 분리된 상태를 준영속 상태라 한다. 따라서 영속 상태에서 사용하던 기능을 사용할 수 없게 된다.

방법은 아래 3가지가 있다.

```
A. .detach(entity) 메소드를 사용해 특정 엔티티만 준영속 상태로 전환한다.
B. .clear() 메소드를 사용해 영속성 컨텍스트를 초기화하여 전부 준영속 상태로 전환한다. 이는 영속성 컨텍스트를 제거하고 새로 만든 것과 같다.
C. .close() 메소드를 사용해 영속성 컨텍스트를 종료하여 전부 준영속 상태로 전환한다. 
```

영속 상태의 엔티티가 준영속 상태로 전환될 경우 컨텍스트 내에서의 해당 엔티티 정보가 제거되어 각종 기능들(1차 캐시, 쓰기 지연 SQL)을 사용할 수 없다. 데이터베이스로 반영도 되지 않는다.

준영속 상태의 엔티티의 특징은 아래와 같다.

```
A. 영속성 컨텍스트가 제공하는 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩을 포함한 기능이 동작하지 않는다.
B. 한 번 영속 상태였기 때문에 식별자 값을 반드시 가지고 있다.
C. 영속성 컨텍스트를 거쳐야 하는 지연 로딩 기능을 사용할 수 없다(A와 같은 내용)
```

준영속 상태의 엔티티를 다시 영속 상태로 돌리려면 병합 기능을 사용해야 한다. 엔티티 매니저의 merge() 메소드를 사용하면 준영속/비영속 상태의 엔티티를 영속 상태의 새로운 엔티티로 받아오게 된다.

merge() 메소드에 집어넣은 준영속 엔티티와, 반환 받은 새로운 영속 엔티티는 서로 다른 객체이므로 이전 엔티티는 사용하지 않아도 된다.

엔티티 매니저의 .contains(엔티티) 메소드를 사용하면 영속성 컨텍스트가 해당 엔티티를 영속 상태로 관리 중인지 확인할 수 있다.

# 정리 (119 페이지) 진행 중

학습한 내용을 정리하면 아래와 같다.

```
A. 영속성 컨텍스트를 사용하려면 엔티티 매니저 팩토리, 엔티티 매니저가 필요하다. 엔티티 매니저를 통해 영속성 컨텍스트에 접근한다.
B. 영속성 컨텍스트는 어플리케이션과 데이터베이스 사이에서 엔티티를 관리하는 가상의 데이터베이스 역할을 한다.
C. 영속성 컨텍스트를 통해 1차 캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기 지원, 변경 감지, 지연 로딩 등의 기능을 사용할 수 있다.
D. 영속성 컨텍스트의 플러시 기능(커밋 실행 시 작동)을 거쳐야 데이터베이스에 실제 데이터 CRUD가 반영된다.
E. 영속성 컨텍스트가 엔티티를 관리하고 있다면 영속 상태이며, 그렇지 않은 상태를 비영속/준영속 상태라 한다. 영속성 컨텍스트의 기능은 영속 상태에서만 사용할 수 있다.
```

===========================================================================4장 : 엔티티 매핑

JPA를 사용하는 데 가장 중요한 것은 엔티티와 테이블을 정확히 매핑하는 것이다. 이를 위해선 매핑 어노테이션을 숙지해야 한다.

아래는 대표적인 어노테이션이다.

```
객체-테이블 매핑 : @Entity, @Table
기본 키 매핑 : @Id
필드-컬럼 매핑 : @Column
연관관계 매핑 : @ManyToOne, @JoinColumn
```

# @Entity 어노테이션 (122~123 페이지)

JPA를 사용해서 테이블과 매핑시킬 클래스는 @Entity 어노테이션을 필수로 붙여야 한다. 이 어노테이션이 붙은 클래스는 JPA가 관리하는 엔티티가 된다.

@Entity 어노테이션을 사용할 클래스는 아래 규칙을 지켜야 한다.

```
A. 기본 생성자가 반드시 있어야 한다.
B. final, enum, interface, inner 클래스에는 사용할 수 없다.
C. 저장할 필드에 final을 사용하면 안 된다.
```

자바의 경우 생성자가 하나도 없으면 기본 생성자를 만들지만, 다른 생성자를 만들 경우 기본 생성자를 만들지 않으므로 직접 만들어야 한다.

# @Table 어노테이션 (123 ~ 124페이지) 진행 중

엔티티와 매핑할 테이블을 지정하려면 @Table 어노테이션을 사용한다. 생략할 경우 매핑한 엔티티 이름을 테이블 이름으로 사용한다고 한다. 하위 속성은 나중에 찾아보기.

# 다양한 매핑 사용 (124 ~ 125페이지) 코드 변경만 있으므로 넘어감

# 데이터베이스 스키마 자동 생성 (125 ~ 129 페이지) 진행 중

JPA에서는 클래스의 매핑 정보와 데이터베이스 방언을 통해 자바 단에서 엔티티만 만든 후 그에 맞게 테이블을 자동 생성시킬 수 있다. 데이터베이스 방언은 나중에 찾아보기.

스키마+테이블 자동 생성 기능을 사용하면 개발자가 테이블을 직접 생성하는 수고를 덜 수 있다.

또한, 자동 생성되는 구조를 통해 엔티티와 테이블이 어떻게 매핑되는지 쉽게 학습하고 이해할 수 있다.

자바의 카멜 표기법과 데이터베이스의 언더스코어 표기법이 서로 다르므로 이름 매핑 전략에 신경 써야 한다. ** 이러한 이름 매핑과 관련된 클래스 org.hibernate.cfg.ImprovedNamingStrategy 나중에 찾아보기.

# DDL 생성 기능 (129 ~ 130 페이지)

스키마 자동 생성을 통해 만들어지는 DDL에 제약조건을 추가시킬 수 있다. @Column과 @Table 어노테이션의 속성을 통해 이러한 제약을 추가시킬 수 있다.

# 기본 키 매핑(131 ~ 144 페이지)

애플리케이션에서 직접 할당하지 않은 값(MySQL의 AUTO_INCREMENT 같은 것들)을 기본 키로 사용하기 위해서는 아래 방법을 취해야 한다.

```
A. 애플리케이션에서 기본 키를 직접 할당한다.
B. IDENTITY, SEQUENCE, TABLE 같은 대리 키 사용 방식을 사용한다. << 데이터베이스마다 사용 가능한 것이 있고 불가능한 것이 있다.
```

기본 키를 직접 할당하려면 필드에 @Id 어노테이션을 사용하여 매핑할 필드를 지정하고, em.persist()로 엔티티를 저장하기 전에 해당 필드 값을 엔티티에 할당시켜둬야 한다.

개발자가 @Id를 쓰지 않고(기본 키를 직접 할당하지 않고) 값 생성을 맡기려면 IDENTITY를 사용한다. MySQL에서도 사용한다. @GeneratedValue 어노테이션과 함께 사용하므로 나중에 찾아보자.

**IDENTITY 식별자 생성은 쓰기 지연이 불가능하다. (식별자가 있어야 지연 쓰기를 하는데, IDENTITY는 데이터베이스에 저장하고 나서야 식별자가 구해지므로, em.persist()를 하는 순간 INSERT까지 들어가버리기 때문)

SEQUENCE 전략 - MySQL에서는 사용하지 않는다고 한다. 일단 패스 나중에 찾아보기

TABLE 전략도 나중에 찾아보기

그 외에 사용 중인 데이터베이스 방언에 따라 위의 전략 중 하나를 자동으로 선택해주는 AUTO 전략도 있다.

식별자 선택 전략을 위해 아래 조건은 기억해 두자.

``` 기본 키의 조건
A. NULL값은 허용하지 않는다.
B. 유일해야 한다
C. 변하지 않아야 한다.
```

```기본 키 선택 전략
A. 자연 키 : 비즈니스적으로 의미가 있는 키. 예시) 주민등록번호, 이메일, 전화번호
B. 대리 키 : 비즈니스적으로는 의미 없는 키. 예시) AUTO_INCREMENT 값, 오라클 시퀀스, 키 생성용 테이블
```

# 필드와 컬럼 매핑 : 레퍼런스 (145 ~ 페이지) 진행 중

필드와 컬럼을 매핑시켜주는 어노테이션을 정리하면 아래와 같다.

```
A. @Column : 컬럼을 매핑한다.
B. @Enumerated : 자바의 enum 타입을 매핑한다.
C. @Temporal : 날짜 타입을 매핑한다.
D. @Lob : BLOB, CLOB 타입을 매핑한다. << 이게 뭔데
E. @Transient : 특정 필드를 데이터베이스에 매핑하지 않는다.
F. @Access : JPA가 엔티티에 접근하는 방식을 지정한다.
```

@Column은 객체 필드를 테이블 컬럼에 매핑시킨다. 가장 많이 사용되며 기능도 많다.

주로 name, nullable 속성이 사용되며 나머지는 잘 사용되지 않는다고 한다. 그 외 속성들은 나중에 읽어보기. 아래는 "거의 사용하지 않음" 이라고 적히지 않은 속성들 정리.

```
nullable : null 값의 허용 여부를 설정한다. false로 설정하면 DDL로 not null 제약 조건을 추가해 준다.
unique : 한 컬럼에 유니크 제약 조건을 건다. 일반적으로는 한 컬럼에만 사용할 수 있는 듯함.
columnDefinition : 데이터베이스 컬럼 정보를 직접 줄 수 있다고 함. 뭔 소린지 모르겠으니 나중에 찾아보기.
length : 문자 길이 제약 조건을 건다. String 타입에만 사용한다.
precision, scale : 고정소수점?에서 전체 자릿수와 소수점 자릿수를 지정할 때 사용한다.
```

** @Column 어노테이션을 생략할 경우 변수형, 객체형에 따라 DDL이 알아서 변환된다.(변수형은 NULL을 못 넣으므로 not null 자동으로 들어가는 식) 이 때 변수형에 @Column을 사용하면 nullable = true가 기본으로 들어가므로 nullable=false를 따로 지정해주는 것이 안전하다.

@Enumerated는 enum 타입을 매핑할 때 사용한다. .ORDINAL, .STRING 등의 속성이 있으며 특징은 아래와 같다.

```
1. .ORDINAL : 지정한 enum  내 값의 순서들만 숫자로 저장한다. 데이터베이스에 저장되는 데이터 크기는 작지만, 저장된 enum의 순서를 변경할 수 없다. 기본 값이지만 주의해서 사용해야 한다.
2. .STRING : 지정한 enun 내 값을 문자열 형태 그대로 저장한다. 저장된 enum의 순서가 바뀌거나 추가되어도 안전하지만, 데이터베이스에 저장되는 데이터 크기가 상대적으로 크다. 이 쪽 사용을 권장한다고 한다.
```

@Temporal은 날짜 타입을 매핑할 때 사용한다. 속성으로 .DATE, .TIME, .TIMESTAMP가 있으며 데이터베이스의 각 타입(date, time, timestamp)과 매핑되며 반드시 지정해줘야 한다.

@Temporal을 생략할 경우 자바의 Date와 가장 유사한 timestamp로 자동 정의된다. MySQL은 datetime으로 변경된다고 한다.

@Lob은 데이터베이스 BLOB과 CLOB 타입과 매핑한다. 별도 속성은 없으며, 매핑시키는 필드 타입이 문자면 CLOB으로, 그 외에는 BLOB으로 매핑시킨다.

**BLOB과 CLOB이란? 대용량 데이터를 저장하는 데이터 타입으로, BLOB은 이미지, 동영상, 오디오, 문서 등의 파일을 저장하고 CLOB은 대용량의 텍스트 데이터(로그, 웹사이트 등)를 저장한다.

@Transient는 매핑을 아예 하지 않는다. 데이터베이스에 저장도 되지 않고 조회도 되지 않는다. 객체에 임시로 어떤 값을 보관하고 싶을 때 사용한다.

@Access는 엔티티 데이터에 접근하는 방식을 지정한다. 필드 접근과 프로퍼티 접근 방식이 있다.

```
필드 접근 : AccessType.FIELD 속성으로 지정한다. 필드에 직접 접근하며 private여도 접근할 수 있다. 
프로퍼티 접근 : AccessType.PROPERTY로 지정한다. 접근자(Getter)를 사용한다.
```

@Access를 설정하지 않으면 @Id 어노테이션이 적용된 위치를 기준(필드인지? 메소드(혹은 필드 외)인지?)를 체크해 접근 방식이 설정된다.

# 정리개발자가 @Id를 쓰지 않고(기본 키를 직접 할당하지 않고) 값 생성을 맡기려면 IDENTITY를 사용한다. MySQL에서도 사용한다. @GeneratedValue 어노테이션과 함께 사용하므로 나중에 찾아보자.

**IDENTITY 식별자 생성은 쓰기 지연이 불가능하다. (식별자가 있어야 지연 쓰기를 하는데, IDENTITY는 데이터베이스에 저장하고 나서야 식별자가 구해지므로, em.persist()를 하는 순간 INSERT까지 들어가버리기 때문)

SEQUENCE 전략 - MySQL에서는 사용하지 않는다고 한다. 일단 패스 나중에 찾아보기

TABLE 전략도 나중에 찾아보기

그 외에 사용 중인 데이터베이스 방언에 따라 위의 전략 중 하나를 자동으로 선택해주는 AUTO 전략도 있다.

식별자 선택 전략을 위해 아래 조건은 기억해 두자.

``` 기본 키의 조건
A. NULL값은 허용하지 않는다.
B. 유일해야 한다
C. 변하지 않아야 한다.
```

```기본 키 선택 전략
A. 자연 키 : 비즈니스적으로 의미가 있는 키. 예시) 주민등록번호, 이메일, 전화번호
B. 대리 키 : 비즈니스적으로는 의미 없는 키. 예시) AUTO_INCREMENT 값, 오라클 시퀀스, 키 생성용 테이블
```

# 필드와 컬럼 매핑 : 레퍼런스 (145 ~ 153 페이지) 진행 중

필드와 컬럼을 매핑시켜주는 어노테이션을 정리하면 아래와 같다.

```
A. @Column : 컬럼을 매핑한다.
B. @Enumerated : 자바의 enum 타입을 매핑한다.
C. @Temporal : 날짜 타입을 매핑한다.
D. @Lob : BLOB, CLOB 타입을 매핑한다. << 이게 뭔데
E. @Transient : 특정 필드를 데이터베이스에 매핑하지 않는다.
F. @Access : JPA가 엔티티에 접근하는 방식을 지정한다.
```

@Column은 객체 필드를 테이블 컬럼에 매핑시킨다. 가장 많이 사용되며 기능도 많다.

주로 name, nullable 속성이 사용되며 나머지는 잘 사용되지 않는다고 한다. 그 외 속성들은 나중에 읽어보기. 아래는 "거의 사용하지 않음" 이라고 적히지 않은 속성들 정리.

```
nullable : null 값의 허용 여부를 설정한다. false로 설정하면 DDL로 not null 제약 조건을 추가해 준다.
unique : 한 컬럼에 유니크 제약 조건을 건다. 일반적으로는 한 컬럼에만 사용할 수 있는 듯함.
columnDefinition : 데이터베이스 컬럼 정보를 직접 줄 수 있다고 함. 뭔 소린지 모르겠으니 나중에 찾아보기.
length : 문자 길이 제약 조건을 건다. String 타입에만 사용한다.
precision, scale : 고정소수점?에서 전체 자릿수와 소수점 자릿수를 지정할 때 사용한다.
```

** @Column 어노테이션을 생략할 경우 변수형, 객체형에 따라 DDL이 알아서 변환된다.(변수형은 NULL을 못 넣으므로 not null 자동으로 들어가는 식) 이 때 변수형에 @Column을 사용하면 nullable = true가 기본으로 들어가므로 nullable=false를 따로 지정해주는 것이 안전하다.

@Enumerated는 enum 타입을 매핑할 때 사용한다. .ORDINAL, .STRING 등의 속성이 있으며 특징은 아래와 같다.

```
1. .ORDINAL : 지정한 enum  내 값의 순서들만 숫자로 저장한다. 데이터베이스에 저장되는 데이터 크기는 작지만, 저장된 enum의 순서를 변경할 수 없다. 기본 값이지만 주의해서 사용해야 한다.
2. .STRING : 지정한 enun 내 값을 문자열 형태 그대로 저장한다. 저장된 enum의 순서가 바뀌거나 추가되어도 안전하지만, 데이터베이스에 저장되는 데이터 크기가 상대적으로 크다. 이 쪽 사용을 권장한다고 한다.
```

@Temporal은 날짜 타입을 매핑할 때 사용한다. 속성으로 .DATE, .TIME, .TIMESTAMP가 있으며 데이터베이스의 각 타입(date, time, timestamp)과 매핑되며 반드시 지정해줘야 한다.

@Temporal을 생략할 경우 자바의 Date와 가장 유사한 timestamp로 자동 정의된다. MySQL은 datetime으로 변경된다고 한다.

@Lob은 데이터베이스 BLOB과 CLOB 타입과 매핑한다. 별도 속성은 없으며, 매핑시키는 필드 타입이 문자면 CLOB으로, 그 외에는 BLOB으로 매핑시킨다.

**BLOB과 CLOB이란? 대용량 데이터를 저장하는 데이터 타입으로, BLOB은 이미지, 동영상, 오디오, 문서 등의 파일을 저장하고 CLOB은 대용량의 텍스트 데이터(로그, 웹사이트 등)를 저장한다.

@Transient는 매핑을 아예 하지 않는다. 데이터베이스에 저장도 되지 않고 조회도 되지 않는다. 객체에 임시로 어떤 값을 보관하고 싶을 때 사용한다.

@Access는 엔티티 데이터에 접근하는 방식을 지정한다. 필드 접근과 프로퍼티 접근 방식이 있다.

```
필드 접근 : AccessType.FIELD 속성으로 지정한다. 필드에 직접 접근하며 private여도 접근할 수 있다.
프로퍼티 접근 : AccessType.PROPERTY로 지정한다. 접근자(Getter)를 사용한다.
```

@Access를 설정하지 않으면 @Id 어노테이션이 적용된 위치를 기준(필드인지? 메소드(혹은 필드 외)인지?)를 체크해 접근 방식이 설정된다.

# 정리 및 실전 예제 (153 ~ 161 페이지) : 정리는 별다른 내용 없어 패스. 실전 예제는 나중에 해보기.

===========================================================================5장 : 연관관계 매핑 기초

엔티티들은 대부분 다른 엔티티와 연관관계를 가진다. 하지만 자바는 객체 참조를 이용해 관계를 맺고 테이블은 외래 키를 통해 관계를 맺는다. 이 서로 다른 관계를 서로 매핑시키는 것은 아주 어렵다.

연관관계를 이해하기 위해 필요한 키워드들은 아래와 같다.

```
방향 : 단방향과 양방향이 있다. 두 단위가 있을 때 한 단위가 다른 한 단위만 참조하면 단방향, 서로 참조하는 것을 양방향이라고 한다.
다중성 : 두 단위가 있을 때 한 단위가 다른
연관관계의 주인 : 

```
