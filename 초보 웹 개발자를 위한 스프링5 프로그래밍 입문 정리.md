공부 방법을 변경하게 되었다.
책 속 코드나 용어를 전부 하나하나 분석하고 정리하는 방향에서, 책에 등장하는 용어나 기법에 대해 간략히 정리하고 기억해둠으로써 책을 빠르게 소화하는 방향으로 바꾸었다.
이는 추후 프로젝트를 시작하게 되었을 때 기억하고 있는 다양한 기법이나 패턴을 떠올릴 수 있게 되는 것에 더욱 힘을 주고 상세한 코드나 기술에 대한 건 프로젝트 중에 직접 체험해가며 실력을 키우는 것이 더욱 효율적이라 판단되었기 때문이다.

# 컴포넌트 스캔(130페이지 ~ 140페이지)

스프링에서 특정 클래스에 이름을 붙여 빈 객체로 등록해주는 기능을 컴포넌트라고 한다.

@Component 어노테이션을 사용하면 특정한 이름, 혹은 본래 클래스 이름(첫 글자만 소문자화시킨)의 빈 객체를 생성할 수 있다.
그리고 @ComponentScan 어노테이션을 사용해, 위 @Component로 등록한 클래스 객체를 Bean 객체로 등록시킨다.

이 과정을 거치면 @Component 어노테이션을 통해 빈 이름을 지정하게 되었으므로 기존의 getBean 메소드에서 이름을 지정할 필요가 없어진다.
그 외 특정 속성을 사용하여 빈 객체 자동 생성 대상을 제외하는 등의 기능이 가능하다.

@Component 어노테이션 외에도 @Controller, @Service, @Repository, @Aspect, @Configuration 등 어노테이션도 역할은 다르지만 같은 빈 검색&등록 기능을 수행한다.
빈 객체 자동 등록 기능을 사용할 때에는 빈 이름 관련, 수동 등록과 관련하여 충돌이 발생할 수 있으니 주의해야 한다.

# 빈 객체의 라이프사이클과 범위(141페이지 ~ 151페이지)

어노테이션을 통해 생성하는 빈 객체들은 개발자의 코드 밖에 있는 저장소인 스프링 컨테이너에 저장된다.
스프링 컨테이너는 필요시 초기화되고 사용을 완료하면 종료되는 사이클을 가지고 있다.
AnnotationConfigApplicationContext 객체를 생성하는 순간이 컨테이너가 초기화되는 순간이다. 이 때 빈 객체가 생성되고, 각 빈끼리의 의존 주입이 실행된다.
컨테이너가 초기화되어 있는 동안, AnnotationConfigApplicationContext 객체의 getBean() 메소드 등을 사용하여 빈 객체에 접근한다.
컨테이너 사용을 마친 후 AnnotationConfigApplicationContext 객체의 close() 메소드를 사용하여 컨테이너를 종료한다. 이 때 컨테이너 내부의 빈 객체가 소멸된다.
빈 객체를 초기화하고 소멸시키는 기능을 담당하는 각 인터페이스가 있는데, 이를 사용할 빈 객체에서 구현한 후 초기화/소멸 시 호출되는 메소드를 사용하면 초기화/소멸 시에 작동시킬 기능을 작성할 수 있다.
직접 생성한 클래스가 아니라 위 인터페이스를 구현할 수 없는 상황이라 해도, @Bean 어노테이션의 initMethod, destroyMethod 속성을 사용하면 초기화/소멸 시 실행시킬 메소드를 작성/지정할 수 있다.
빈 객체는 기본적으로 싱글톤(singleton) 범위로 하나의 객체만 생성되어 공유된다. 같은 이름의 다른 빈 객체를 생성할 수도 있지만 사용 빈도는 낮다.

# AOP 패턴에 대하여 (152 ~ 177페이지)

특정 기능이나 클래스를 여러가지 개발하다 보면 공통적으로 사용되는 코드가 생기기 마련이다.
예시 1) DBMS 사용 시, 자바 코드상으로 DB로 데이터를 전송하기 위해 자바와 DB를 중개해주는 객체를 생성하고 close 하는 과정
예시 2) 특정 기능들에 해당 기능이 1회 완료될 때까지 걸리는 시간의 로그를 남기는 과정

이러한 코드들을 매번 작성하는 것보다 별도로 나누어서 관리할 수 있게 된다면 해당 코드들을 반복해서 작성할 필요가 없을 것이다.
또한 반복되는 코드를 부품화하여 사용할 수 있기 때문에 핵심 기능의 개발에만 집중할 수 있을 것이다.

이렇게 여러 클래스를 개발할 때 '공통 기능' 과 '핵심 로직' 을 별도로 분리해서 개발/관리하는 패턴을 AOP(Aspect-Oriented Programming / 관점 지향 프로그래밍)라고 한다.
반복적으로 사용하게 될 공통 기능을 구상하게 되거나, 기존의 공통 코드를 간소화하여 코드를 경량화시키는 데 큰 도움이 될 것이다. 기억해 두자.

위의 AOP 패턴을 구현할 때 필요한 것이 프록시 객체이다. 공통 기능과 핵심 로직을 구분했을 때, 공통 기능을 담당하는 코드만 가지고 핵심 로직은 메소드는 다른 객체들 가져와 실행하는 객체가 프록시 객체이다.
프록시 객체의 핵심은 공통 기능만 구현하는 것이다. 핵심 로직은 외부 객체를 사용한다.

AOP 패턴을 사용할 때 사용하는 주요 용어는 아래와 같다.
1. Advice : 핵심 로직 외에 적용할 공통 기능을 가리킨다.
2. Joinpoint : Advice, 즉 핵심 로직을 적용할 지점을 정의한다. 가장 대표적인 경우는 메서드 호출이다.
3. Pointcut : Joinpoint의 보다 일반적인 범주를 지정한다.
4. Weaving : 공통 기능인 Advice을 적용 시점인 Pointcut에 실제 적용하는 작업이다.
5. Aspect : 위의 Advice부터 Point까지 작성한, 목적과 작동이 확정된 공통 기능의 단위이다.

스프링에서 널리 사용되는 공통 기능(Advice)는 메서드 실행 전/후, 예외 발생 시 작동할 기능(Around Advice)이다.
스프링에서는 어노테이션을 통해 AOP 패턴을 담당하는 위 기능들을 지정한다. @Aspect, @Around, @Pointcut 등의 어노테이션을 사용한다. 그 외의 AOP 관련 어노테이션들은 추후 공부하는 것으로.

# DB 연동에 대하여(178페이지 ~ 231P)

## JdbcTemplate 클래스
JDBC를 사용할 경우 실질적인 프로젝트의 기능과 관계가 없지만 구조적으로 반복되는 코드가 생기게 된다. 스프링에서 제공하는 JdbcTemplate 클래스를 활용하면 이 반복을 줄일 수 있고, 편하게 쿼리를 실행시킬 수 있다.

## 트랜잭션
스프링을 사용하면 트랜잭션 관리 또한 쉬워진다. 트랜잭션이란 "시작부터 끝까중

