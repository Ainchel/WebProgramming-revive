웹 프로그래밍에서 자주 사용되는 MVC 패턴에서는 클래스 간의 역할을 명확히 구분하게 된다.
따라서 한 클래스에서 여러 기능을 구현하지 않고, 다른 클래스의 기능을 가져와 사용하는 경우가 많아지게 된다.
이 과정에서 A 클래스가 B 클래스의 필드나 메소드를 사용하게 될 경우 'A 클래스는 B 클래스를 의존한다' 고 표현하게 된다.

이와 같은 상황에서, A 클래스 내부에서 직접 B 클래스의 객체를 생성하게 될 경우 '강하게 의존한다' 고 표현하며, 다른 클래스를 사용하게 되었을 때나 테스트를 진행할 때 코드를 대량 수정해야 하는 불편함이 생긴다.

아래는 A 클래스가 B 클래스를 강하게 의존하게 되는 경우의 예제 코드이다.

~~~
public class B1{
  public void print(){
    system.out.println("B1 클래스에 의존 중입니다.")
  }
}

public class A{

  private final B1 b1;

  public A(){
    this.b1 = new B1(); // A 클래스 내부에서 B 클래스의 객체를 직접 생성하고 있으며, 이를 '강하게 의존한다' 고 표현한다.
  }

  public void Call(){
    b.print(); // "B1 클래스에 의존 중입니다." 출력
  }
}
~~~

그리고, 위와 같은 강한 의존 상태에서 A 클래스를 실제로 사용한다면 아래 코드처럼 될 것이다.

~~~
public class Main{
  public static void main(String[] args) {
          A a = new A();  // A 클래스의 인스턴스인 a 생성
          a.CallB();  // A 클래스에서 의존 중인 B1 클래스의 print 메소드를 실행. "B1 클래스에 의존 중입니다."
      }
}
~~~

그렇다면 위처럼 코드를 작성했을 때, 만약 B1과 비슷한 작동을 하는 새로운 클래스인 B2를 생성했다고 하자.

~~~
public class B2{
  public void print(){
    system.out.println("B2 클래스에 의존 중입니다.")
  }
}
~~~

이 경우, A 클래스에서 B1 클래스가 아닌 B2 클래스를 참조하려면 코드를 아래와 같이 수정해야 한다.

~~~
public class A{

  private final B2 b2; // 이 행을 수정해야 한다.

  public A(){
    this.b2 = new B2(); // 이 행을 수정해야 한다.
  }

  public void CallB(){
    b2.print(); // 이 행을 수정해야 한다.
  }
}
~~~

이처럼 강한 의존 상태에서는 의존하고 있는 클래스를 변경하게 될 경우 A 클래스의 코드를 직접 수정해야 되는 일이 생긴다. 만일 의존해야 하는 클래스의 종류가 여러개라면, 클래스를 바꿔낄 때마다 코드를 수정해줘야 한다.
그렇다면, 아래처럼 코드를 바꾸게 된다면 어떨까? 먼저, 다른 클래스를 의존해야 되는 A 클래스의 코드부터 수정해 보자.

~~~
public class A{

  private final B b; // 의존할 클래스의 객체를 멤버로 선언한다.

  public A(B b){ // 최중요 코드 1. 클래스의 생성자 패러미터로 의존할 클래스를 받아온다.
    this.b = b; // 최중요 코드 2. 클래스 내부에서 직접 객체를 생성하지 않고, 생성자 패러미터로 받아온 객체를 클래스 멤버에 집어넣는다.
  }

  public void CallB(){
    b.print(); // 생성자 패러미터로 받아온 객체의 메소드를 실행한다. (패러미터로 받아온 클래스에 print 메소드가 있어야 한다.)
  }
}
~~~

그 다음, 비슷한 메소드 구성을 가지는 클래스 B1과 B2 클래스를 묶을 InterFace B를 만든 후 B1과 B2에 각각 구현시켜 보자.

~~~

//인터페이스 B를 선언 후, B1과 B2에서 사용할 메소드인 print를 선언

public interface B {
  public print();
}

//위의 B1과 B2 클래스의 코드를 B 인터페이스로 구현시키게끔 수정한다.

public class B1 implements B{ // 클래스 선언부에 인터페이스를 구현하겠다는 'implements' 명령어와 그 대상인 인터페이스 B를 지정
  public void print(){
    system.out.println("B1 클래스에 의존 중입니다.")
  }
}

public class B2 implements B{
  public void print(){
    system.out.println("B2 클래스에 의존 중입니다.")
  }
}

~~~

위 코드처럼 코드를 수정한다면, Main 메소드에서는 어떤 변화가 생길까?

~~~
public class Main{
  public static void main(String[] args) {
          B1 b1 = new B1();  // A가 의존할 클래스인 B1의 객체를 먼저 생성한다.
          A a = new A(b1);  // A 클래스 내부에서 의존하는 클래스의 객체를 직접 생성하지 않고, 생성자를 통해 의존할 클래스의 객체를 전해준다.
          a.CallB(); // a 객체 생성 시 전달받은 b1 객체의 print(); 메소드를 실행한다.
      }
}
~~~

위와 같이 A 클래스의 구조와 Main 메소드를 변경했다면, A가 의존하는 클래스를 B1에서 B2로 교체해야 할 경우 코드가 어떻게 바뀔까?

~~~
public class Main{
  public static void main(String[] args) {
          B2 b2 = new B2();  // A가 의존할 클래스를 B1에서 B2로 교체해야 하므로 객체를 B2 객체로 생성한다.
          A a = new A(b2);  // A 클래스 내부에서 의존하는 클래스 객체를 b1에서 b2로 교체했다.
          a.CallB(); // a 객체 생성 시 전달받은 객체가 b1에서 b2로 교체되었으므로, B2 클래스의 print(); 메소드가 실행된다. //"B2 객체에 의존하고 있습니다."
      }
}
~~~
