# 들어가며 (26 ~ 28페이지) : 이 책을 왜 썼는지, 읽는 데 어떤 것들이 필요한지 나와있어서 정리함

JPA를 이해하려면 아래 목록에 있는 기술에 대한 기초적인 이해가 필요하다.
 자바 언어와 JDBC를 사용한 데이터베이스 프로그래밍, 그리고 객체지향 프로그래밍과 관계형 데이터베이스에 대한 
A. JAVA
B. JDBC를 사용한 데이터베이스 프로그래밍
C. 객체지향 프로그래밍
D. 관계형 데이터베이스
E. 웹 개발과 스프링 프레임워크
F. JUnit
G. 메이븐

JPA는 크게 객체와 테이블을 매핑하는 설계, 그리고 설계한 모델을 사용하는 부분으로 나뉜다.

1~9장은 이론 편이다. 이론에 대해서 집중적으로 공부할 것 같다.

JPA를 사용하면 개발 생산성과 유지보수가 좋아지고 코드 품질과 테스트에 더 많은 시간을 할애할 수 있다.

==========================================================1장 : JPA 소개

JDBC와 마이바티스(MyBatis), JdbcTemplate를 함께 사용해도, 기본적인 CRUD용 SQL은 반복해서 작성해야 했다. 이는 매우 비생산적이고 확장성이 부족했다.

이를 해결하기 위한 것은 객체 모델링이었으나, SQL만으로는 객체 모델링에 많은 어려움이 따랐다.

이러한 객체-데이터베이스 간 차이를 메워주는 것이 ORM(Object Relational Mapping)이다. JPA는 ORM의 자바 버전이라고 생각하자.

JPA는 반복적인 CRUD SQL을 처리해주며 조회 결과를 객체로 자동으로 매핑해준다. 또한 데이터베이스를 변경할 때 코드 수정이 간편하다.

# SQL을 직접 다룰 때 발생하는 문제점 (32페이지 ~ 39페이지)

자바로 개발하는 애플리케이션은 대부분 관계형 데이터베이스를 사용하고, 이 경우 JDBC를 통해 SQL을 다룬다.

이 경우 자바-DB 간 상호작용은 다음과 같이 이루어질 것이다.

A. 데이터 조회에 필요한 SQL을 작성한다.
B. JDBC를 사용해서 SQL을 실행시킨다.
C. 조회 결과를 자바 클래스 객체로 매핑한다.

위 결과를 거쳐 조회한 자바 클래스 객체를 자바 컬렉션에 보관할 경우, 개발자는 SQL과 JDBC를 사용해 데이터를 객체로 변환하는 작업을 반드시 거쳐야 한다.

이러한 CRUD를 진행하려면 SQL과 JDBC API를 반복해야 한다.

위 과정에서 데이터 사양이 하나 추가될 경우 클래스, CRUD SQL, JDBC 객체를 모두 수정해야 한다.

또한 자바 단의 DAO에서 어떤 SQL을 사용하고 있는지 하나하나 확인해야 된다. 즉, 엔티티(비즈니스 요구사항을 위해 만들어진 객체)와의 의존관계가 너무나 강해진다.

위 상황에서 JPA를 사용할 경우, CRUD 과정에서 개발자가 직접 SQL을 작성하지 않고 JPA의 API를 활용하게 된다.

# 패러다임의 불일치 (40 ~ 53 페이지)

현대의 복잡한 애플리케이션은 대부분 객체지향 언어로 개발되고 있다.

자바에서 이렇게 다루고 있는 객체들을 데이터베이스에 저장해야 하는데, 데이터베이스에는 자바에서 다루는 객체지향적 기술이나 개념이 없다.

이는 애초에 자바와 관계형DB가 지향하는 목적이 서로 다르기 때문이다. 이를 패러다임 불일치 문제라고 한다.

이 둘의 불일치 문제는 개발자가 해결해야 하는데, 이 과정에서 많은 시간과 코드를 소비하게 된다.

예시) 자바의 상속 클래스 관계는 DB에서 온전히 구현되지 못해, 부모와 자식 클래스에 해당하는 두 테이블의 데이터를 따로따로 다루고 합쳐야만 한다.

## 이 경우 JPA를 사용하면 자바에서 상속된 클래스를 다루면 내부적으로 쿼리를 생성해 준다.

자바에서는 다른 객체와 연관관계를 가질 때 참조를 사용한다. 반면 테이블(DB)은 외래키를 사용해 연관관계를 만들고 조인을 사용해 조회한다.

이러한 차이 때문에 객체 쪽에서 DB에 맞춰 모양을 바꾸면 객체지향이 사라지고, 객체지향을 살릴 경우 DB에 저장하거나 조회하기가 어려워지는 이지선다에 걸린다.

## 이 경우 JPA를 사용하면 자바 객체에서 설정한 결과를 SQL로 변환해 준다. DB에서 다루는 외래키를 참조 관계로 변환하는 것 또한 처리해 준다.

또한, SQL을 직접 다룰 경우 SQL로의 의존성이 너무 커져 객체로 변환시킨 데이터를 어디까지 조회할 수 있는지 SQL을 직접 확인해야만 알 수 있다.

그렇다고 데이터베이스의 모든 데이터를 객체로 만들어 메모리에 올려두는 것은 현실성이 없으므로, 필요한 데이터만 뽑는 메소드를 수없이 만들어 사용해야 한다.

## 이 경우 JPA를 사용하면 지연 로딩 기능을 통해 데이터를 한번에 조회할지, 실제로 필요한 지점에 필요한 데이터만 조회할지 자유롭게 선택할 수 있다.

객체와 DB에서의 값 비교 방법에서도 차이가 있다. DB는 각 행의 키 값으로 구분하지만, 객체의 경우 ==(주소값 확인), .equals(들어간 값 확인)로 구분한다.

이때문에 DB에서 조회한 같은 데이터를 같은 인스턴스로(같은 주소값을 가진 객체로) 반환하는 것 또한 쉽지 않다.

## 이 경우 JPA를 사용하면 같은 트랜잭션일 때 같은 객체로 조회되는 것을 보장해 준다(한 번의 코드로 조회한 데이터라면, 주소값이 같은 객체로 반환해 준다.)

# JPA란 무엇인가? (54 ~ 59 페이지) 진행 중

JPA는 애플리케이션과 JDBC 사이에서 동작하는 ORM이다. ORM은 객체와 관계형 데이터베이스를 매핑해준다.

ORM의 장점은 객체와 DB를 자연스럽게 이어줌과 동시에 패러다임 불일치를 자동으로 해결해 준다는 것이다. 자바는 자바스럽게(객체지향에 맞게) 코딩하면 되고, DB는 DB스럽게 만들면 된다.

이러한 ORM 프레임워크로 많이 사용되는 것이 하이버네이트이다.

JPA의 장점을 정리하자면 아래와 같다.

A. 자바에서 객체를 다루는 것과 같이 JPA를 이용하면 CRUD SQL 작성과 JDBC API를 쓰는 과정이 자동으로 처리되어 생산성이 올라간다.
B. 엔티티(객체)에 필드를 추가하기만 하면 자동으로 관련 SQL, JDBC를 자동으로 수정해줘 유지보수가 간편해진다.
C. 패러다임 불일치 문제를 자동으로 처리해주어 개발자의 수고를 덜 수 있다.
D. 데이터베이스와의 통신 등에서 내부적으로 최적화를 진행하여 성능 면에서 우수하다.
E. 다른 데이터베이스를 사용하게 되어도 JPA를 거치면 변경이 수월하다.

# ORM에 대한 궁금증과 오해 (60 ~ 62 페이지). 별다른 내용 없어서 패스. 중요한 건 ORM은 객체지향과 관계형데이터베이스를 전제로 한 기술이라는 것.

===================================================2장 : JPA 시작(64 ~ 88페이지) - 설치 및 환경 설정 관련이므로 패스. 

===================================================3장 : 영속성 관리

# 엔티티 매니저 팩토리와 엔티티 매니저(90 ~ 91 페이지) 진행 중

JPA에서 엔티티와 테이블을 매핑한다고 했다. 이렇게 매핑된 엔티티를 실제 사용하는 데 엔티티 매니저를 거쳐야 한다.

엔티티 매니저는 엔티티를 저장/수정/삭제/조회하는 등 엔티티와 관련된 모든 일을 처리한다.

엔티티 매니저는 가상의 데이터베이스라고 생각하면 된다. 엔티티 매니저를 생성하려면 먼저 엔티티 매니저 팩토리를 생성해야 한다.

DB를 하나 쓰는 애플리케이션은 보통 EntityManagerFactory를 하나 생성한다. 

```
EntityManagerFactory emf = Persistence.createEntityManagerFactory("팩토리이름"); << 엔티티 매니저 팩토리 생성. 비용이 많이 든다고 함
EntityManager em = emf.createEntityManager(); << 엔티티 매니저 생성. 비용 거의 안 든다고 함
```

엔티티 매니저 팩토리에는 여러 스레드가 동시에 접근해도 되지만, 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 공유해선 안 된다.

EntityManagerFactory를 생성하면 보통 커넥션풀도 같이 생성한다.

# 영속성 컨테스트란? (92페이지)

JPA를 이해하는 데 가장 중요한 용어는 영속성 컨텍스트다. 이는 '엔티티를 영구 저장하는 환경' 을 말하며, 엔티티 매니저를 이용할 때 같이 사용된다.

영속성 컨테스트는 논리적인 개념에 가까우며 엔티티 매니저를 생성할 때 하나 만들어진다.

# 엔티티의 생명주기 (92 ~ 94 페이지)

엔티티에는 4가지 상태가 존재한다.

```
A. 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태
B. 영속 : 영속성 컨텍스트에 저장된 상태
C. 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
D. 삭제 : 삭제된 상태
```

비영속 상태는 엔티티 객체를 생성했지만 저장하지는 않은 상태로, 이 때 엔티티는 영속성 컨텍스트나 DB와는 전혀 관련이 없다.

영속 상태는 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장한 상태다. 이 때부터 엔티티는 영속성 컨텍스트를 통해 관리하게 된다. 또한 조회 중인 엔티티도 영속 상태이다.

준영속 상태는 영속 상태이던 엔티티를 영속성 컨텍스트가 관리하지 않게 되는 상태이다. 영속성 컨텍스트를 닫거나 초기화해도 그 엔티티는 준영속 상태가 된다.

삭제 상태는 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한 상태이다.

# 영속성 컨텍스트의 특징 (95 ~ 페이지) 진행 중

영속성 컨텍스트는 엔티티를 식별자 값(@Id를 통해 테이블의 기본 키와 매핑한 값) 으로 구분한다.

즉, 영속 상태의 엔티티는 반드시 식별자 값을 가지게 된다. 식별자 값이 없다면 예외가 발생한다.

영속성 컨텍스트에 저장된 엔티티는 트랜잭션이 커밋되는 순간 해당 엔티티를 DB에 반영한다. 이를 플러시(Flush)라 한다.

영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이를 1차 캐시라고 한다. 영속 상태의 엔티티는 모두 여기에 저장되며, Map 형식으로 @Id-엔티티 객체 형식으로 연결되어 있다.

1차 캐시에 들어간 상태의 엔티티는 아직 데이터베이스에 저장되지 않으며, 이곳에 데이터를 저장하고 조회하는 모든 기준은 데이터베이스의 기본 키 값과 연결되어 있는 식별자 값이다.

데이터를 조회하는 .find() 메소드는 호출 시 먼저 1차 캐시에서 엔티티를 찾아보고, 있다면 데이터베이스 조회 없이 불러와 사용한다. 만약 없다면 DB를 찾아가 조회한다.

영속성 컨텍스트 단에서 불러온 객체는 1차 캐시에서 불러온 같은 객체임으로 객체 동일성을 보장한다.

JPA는 트랜잭션이 커밋되는 순간 데이터베이스에 SQL을 쏘며, 그 이전까지는 컨텍스트 안에만 있는 상태이다.

엔티티 매니저는 트랜잭션 커밋 전까지 내부 쿼리 저장소에 쿼리들을 모아두었다 커밋 때 적용한다. 이를 쓰기 지연이라고 한다. 쿼리를 한 번에 전달하므로써 성능을 최적화할 수 있다고 한다.

SQL로 데이터를 수정하려면 수정 쿼리를 직접 작성해야 한다. 이는 비즈니스 로직이 SQL에 계속해서 의존해야만 하는(로직 돌아가는 걸 확인하려면 자꾸 쿼리문을 확인해야만 하는) 문제점을 낳는다.

JPA에서는 엔티티의 변경사항이 생겼을 경우, 해당 엔티티의 데이터를 변경만 해두면 DB에 자동으로 반영이 된다. 이를 변경 감지 기능이라고 한다.

변경 감지 기능은 영속성 컨텍스트에 보관할 때의 엔티티 데이터와, 플러시 시점(커밋 시점)의 엔티티 데이터를 비교하여 변경된 데이터를 플러시 시점에 UPDATE 시켜준다.

변경 감지 기능은 영속성 컨텍스트가 관리 중인 엔티티(즉 영속 상태)에만 적용된다. 비영속이나 준영속 상태의 엔티티에는 적용되지 않는다.

변경 감지 적용 시, 변경할 데이터만 UPDATE하지 않고 엔티티의 모든 필드를 UPDATE한다. 이는 쿼리의 재사용성(쿼리문 스타일 조회한 같은 데이터를 같은 인스턴스로(같은 주소값을 가진 객체로) 반환하는 것 또한 쉽지 않다.

## 이 경우 JPA를 사용하면 같은 트랜잭션일 때 같은 객체로 조회되는 것을 보장해 준다(한 번의 코드로 조회한 데이터라면, 주소값이 같은 객체로 반환해 준다.)

# JPA란 무엇인가? (54 ~ 59 페이지) 진행 중

JPA는 애플리케이션과 JDBC 사이에서 동작하는 ORM이다. ORM은 객체와 관계형 데이터베이스를 매핑해준다.

ORM의 장점은 객체와 DB를 자연스럽게 이어줌과 동시에 패러다임 불일치를 자동으로 해결해 준다는 것이다. 자바는 자바스럽게(객체지향에 맞게) 코딩하면 되고, DB는 DB스럽게 만들면 된다.

이러한 ORM 프레임워크로 많이 사용되는 것이 하이버네이트이다.

JPA의 장점을 정리하자면 아래와 같다.

A. 자바에서 객체를 다루는 것과 같이 JPA를 이용하면 CRUD SQL 작성과 JDBC API를 쓰는 과정이 자동으로 처리되어 생산성이 올라간다.
B. 엔티티(객체)에 필드를 추가하기만 하면 자동으로 관련 SQL, JDBC를 자동으로 수정해줘 유지보수가 간편해진다.
C. 패러다임 불일치 문제를 자동으로 처리해주어 개발자의 수고를 덜 수 있다.
D. 데이터베이스와의 통신 등에서 내부적으로 최적화를 진행하여 성능 면에서 우수하다.
E. 다른 데이터베이스를 사용하게 되어도 JPA를 거치면 변경이 수월하다.

# ORM에 대한 궁금증과 오해 (60 ~ 62 페이지). 별다른 내용 없어서 패스. 중요한 건 ORM은 객체지향과 관계형데이터베이스를 전제로 한 기술이라는 것.

===================================================2장 : JPA 시작(64 ~ 88페이지) - 설치 및 환경 설정 관련이므로 패스. 

===================================================3장 : 영속성 관리

# 엔티티 매니저 팩토리와 엔티티 매니저(90 ~ 91 페이지) 진행 중

JPA에서 엔티티와 테이블을 매핑한다고 했다. 이렇게 매핑된 엔티티를 실제 사용하는 데 엔티티 매니저를 거쳐야 한다.

엔티티 매니저는 엔티티를 저장/수정/삭제/조회하는 등 엔티티와 관련된 모든 일을 처리한다.

엔티티 매니저는 가상의 데이터베이스라고 생각하면 된다. 엔티티 매니저를 생성하려면 먼저 엔티티 매니저 팩토리를 생성해야 한다.

DB를 하나 쓰는 애플리케이션은 보통 EntityManagerFactory를 하나 생성한다. 

```
EntityManagerFactory emf = Persistence.createEntityManagerFactory("팩토리이름"); << 엔티티 매니저 팩토리 생성. 비용이 많이 든다고 함
EntityManager em = emf.createEntityManager(); << 엔티티 매니저 생성. 비용 거의 안 든다고 함
```

엔티티 매니저 팩토리에는 여러 스레드가 동시에 접근해도 되지만, 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 공유해선 안 된다.

EntityManagerFactory를 생성하면 보통 커넥션풀도 같이 생성한다.

# 영속성 컨테스트란? (92페이지)

JPA를 이해하는 데 가장 중요한 용어는 영속성 컨텍스트다. 이는 '엔티티를 영구 저장하는 환경' 을 말하며, 엔티티 매니저를 이용할 때 같이 사용된다.

영속성 컨테스트는 논리적인 개념에 가까우며 엔티티 매니저를 생성할 때 하나 만들어진다.

# 엔티티의 생명주기 (92 ~ 94 페이지)

엔티티에는 4가지 상태가 존재한다.

```
A. 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태
B. 영속 : 영속성 컨텍스트에 저장된 상태
C. 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
D. 삭제 : 삭제된 상태
```

비영속 상태는 엔티티 객체를 생성했지만 저장하지는 않은 상태로, 이 때 엔티티는 영속성 컨텍스트나 DB와는 전혀 관련이 없다.

영속 상태는 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장한 상태다. 이 때부터 엔티티는 영속성 컨텍스트를 통해 관리하게 된다. 또한 조회 중인 엔티티도 영속 상태이다.

준영속 상태는 영속 상태이던 엔티티를 영속성 컨텍스트가 관리하지 않게 되는 상태이다. 영속성 컨텍스트를 닫거나 초기화해도 그 엔티티는 준영속 상태가 된다.

삭제 상태는 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한 상태이다.

# 영속성 컨텍스트의 특징 (95 ~ 106 페이지) 진행 중

영속성 컨텍스트는 엔티티를 식별자 값(@Id를 통해 테이블의 기본 키와 매핑한 값) 으로 구분한다.

즉, 영속 상태의 엔티티는 반드시 식별자 값을 가지게 된다. 식별자 값이 없다면 예외가 발생한다.

영속성 컨텍스트에 저장된 엔티티는 트랜잭션이 커밋되는 순간 해당 엔티티를 DB에 반영한다. 이를 플러시(Flush)라 한다.

영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이를 1차 캐시라고 한다. 영속 상태의 엔티티는 모두 여기에 저장되며, Map 형식으로 @Id-엔티티 객체 형식으로 연결되어 있다.

1차 캐시에 들어간 상태의 엔티티는 아직 데이터베이스에 저장되지 않으며, 이곳에 데이터를 저장하고 조회하는 모든 기준은 데이터베이스의 기본 키 값과 연결되어 있는 식별자 값이다.

데이터를 조회하는 .find() 메소드는 호출 시 먼저 1차 캐시에서 엔티티를 찾아보고, 있다면 데이터베이스 조회 없이 불러와 사용한다. 만약 없다면 DB를 찾아가 조회한다.

영속성 컨텍스트 단에서 불러온 객체는 1차 캐시에서 불러온 같은 객체임으로 객체 동일성을 보장한다.

JPA는 트랜잭션이 커밋되는 순간 데이터베이스에 SQL을 쏘며, 그 이전까지는 컨텍스트 안에만 있는 상태이다.

엔티티 매니저는 트랜잭션 커밋 전까지 내부 쿼리 저장소에 쿼리들을 모아두었다 커밋 때 적용한다. 이를 쓰기 지연이라고 한다. 쿼리를 한 번에 전달하므로써 성능을 최적화할 수 있다고 한다.

SQL로 데이터를 수정하려면 수정 쿼리를 직접 작성해야 한다. 이는 비즈니스 로직이 SQL에 계속해서 의존해야만 하는(로직 돌아가는 걸 확인하려면 자꾸 쿼리문을 확인해야만 하는) 문제점을 낳는다.

JPA에서는 엔티티의 변경사항이 생겼을 경우, 해당 엔티티의 데이터를 변경만 해두면 DB에 자동으로 반영이 된다. 이를 변경 감지 기능이라고 한다.

변경 감지 기능은 영속성 컨텍스트에 보관할 때의 엔티티 데이터와, 플러시 시점(커밋 시점)의 엔티티 데이터를 비교하여 변경된 데이터를 플러시 시점에 UPDATE 시켜준다.

변경 감지 기능은 영속성 컨텍스트가 관리 중인 엔티티(즉 영속 상태)에만 적용된다. 비영속이나 준영속 상태의 엔티티에는 적용되지 않는다.

변경 감지 적용 시, 변경할 데이터만 UPDATE하지 않고 엔티티의 모든 필드를 UPDATE한다. 이는 쿼리의 재사용성(쿼리문 스타일이 동일하므로)을 고려한 것이다.

확장 기능을 사용하면 동적으로 UPDATE하는 쿼리도 생성할 수 있다. @org.hibernate.annotations.DynamicUpdate 어노테이션 나중에 찾아보자.

엔티티를 삭제하는 .remove() 메소드를 사용하면 여태까지와 비슷하게 1차 캐시에 쿼리를 두었다가 플러시 시점에 적용시킨다. 엔티티는 메소드 호출 즉시 영속성 컨텍스트에서 제거된다.

# 플러시 (107 ~ 108 페이지) 진행 중

플러시는 영속성 컨텍스트에 저장된 각종 쿼리 및 변경 사항을 DB에 반영하는 단계이다.

플러시 시 변경 감지를 동작해 영속성 컨텍스트 내의 모든 엔티티를 스냅샷(컨텍스트 들어올 때의 엔티티 데이터 최초 상태)과 비교해 수정된 엔티티를 찾고, 그 후 쓰기 지연 SQL 저장소에 쿼리를 등록하고 전송한다.

영속성 컨텍스트를 플러시하는 방법은 아래 3가지이다.

```
A. em.flush()를 호출한다. JPA와 다른 프레임워크를 함꼐 사용하는 경우가 아니면 거의 사용되지 않는다고 한다.
B. 트랜잭션 커밋 시 자동으로 호출된다. JPA는 트랜잭션을 커밋할 경우 데이터베이스로의 반영을 위해 자동으로 플러시를 호출시킨다.
C. JPQL 쿼리 실행 시 자동으로 호출된다. 객체지향 쿼리를 호출할 경우 플러시가 자동으로 실행된다. 이는 쿼리 호출 떄 데이터베이스에 컨텍스트 변경이 반영되어 있어야 하기 때문이다.
```

** 식별자를 기준으로 데이터를 조회하는 find() 메소드를 호출할 때에는 플러시가 실행되지 않는다. 즉 컨텍스트 단계에만 있는 데이터들은 find로 조회할 수 없다.

엔티티 매니저를 통해 플러시 옵션을 지정할 수 있다. javax.persistence.FlushModeType 객체에 대해 한번 조사해 보자. 기본은 커밋이나 쿼리를 실행할 때 플러시한다.

** 플러시 시, 영속성 컨텍스트에 보관된 엔티티는 삭제되지 않는다.

# 준영속 (109 ~ 114페이지 ) 진행 중

영속성 컨텍스트에서 관리하는 엔티티가 컨텍스트에서 분리된 상태를 준영속 상태라 한다. 따라서 영속 상태에서 사용하던 기능을 사용할 수 없게 된다.

방법은 아래 3가지가 있다.

```
A. .detach(entity) 메소드를 사용해 특정 엔티티만 준영속 상태로 전환한다.
B. .clear() 메소드를 사용해 영속성 컨텍스트를 초기화하여 전부 준영속 상태로 전환한다. 이는 영속성 컨텍스트를 제거하고 새로 만든 것과 같다.
C. .close() 메소드를 사용해 영속성 컨텍스트를 종료하여 전부 준영속 상태로 전환한다. 
```

영속 상태의 엔티티가 준영속 상태로 전환될 경우 컨텍스트 내에서의 해당 엔티티 정보가 제거되어 각종 기능들(1차 캐시, 쓰기 지연 SQL)을 사용할 수 없다. 데이터베이스로 반영도 되지 않는다.

준영속 상태의 엔티티의 특징은 아래와 같다.

