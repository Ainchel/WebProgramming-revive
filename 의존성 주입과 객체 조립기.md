웹 프로그래밍에서 자주 사용되는 MVC 패턴에서는 클래스 간의 역할을 명확히 구분하게 된다.
따라서 한 클래스에서 여러 기능을 구현하지 않고, 다른 클래스의 기능을 가져와 사용하는 경우가 많아지게 된다.
이 과정에서 A 클래스가 B 클래스의 필드나 메소드를 사용하게 될 경우 'A 클래스는 B 클래스를 의존한다' 고 표현하게 된다.

이와 같은 상황에서, A 클래스 내부에서 직접 B 클래스의 객체를 생성하게 될 경우 '강하게 의존한다' 고 표현하며, 다른 클래스를 사용하게 되었을 때나 테스트를 진행할 때 코드를 대량 수정해야 하는 불편함이 생긴다.

아래는 A 클래스가 B 클래스를 강하게 의존하게 되는 경우의 예제 코드이다.

~~~
public class B1{
  public void print(){
    system.out.println("B1 클래스에 의존 중입니다.")
  }
}

public class A{

  private final B1 b1;

  public A(){
    this.b1 = new B1(); // A 클래스 내부에서 B 클래스의 객체를 직접 생성하고 있으며, 이를 '강하게 의존한다' 고 표현한다.
  }

  public void CallB(){
    b.print(); // "B1 클래스에 의존 중입니다." 출력
  }
}
~~~

그리고, 위와 같은 강한 의존 상태에서 A 클래스를 실제로 사용한다면 아래 코드처럼 될 것이다.

~~~
public class Main{
  public static void main(String[] args) {
          A a = new A();  // A 클래스의 인스턴스인 a 생성
          a.CallB();  // A 클래스에서 의존 중인 B1 클래스의 print 메소드를 실행. "B1 클래스에 의존 중입니다."
      }
}
~~~

그렇다면 위처럼 코드를 작성했을 때, 만약 B1과 비슷한 작동을 하는 새로운 클래스인 B2를 생성했다고 하자.

~~~
public class B2{
  public void print(){
    system.out.println("B2 클래스에 의존 중입니다.")
  }
}
~~~

이 경우, A 클래스에서 B1 클래스가 아닌 B2 클래스를 참조하려면 코드를 아래와 같이 수정해야 한다.

~~~
public class A{

  private final B2 b2; // 이 행을 수정해야 한다.

  public A(){
    this.b2 = new B2(); // 이 행을 수정해야 한다.
  }

  public void CallB(){
    b2.print(); // 이 행을 수정해야 한다.
  }
}
~~~

이처럼 강한 의존 상태에서는 의존하고 있는 클래스를 변경하게 될 경우 A 클래스의 코드를 직접 수정해야 되는 일이 생긴다. 만일 의존해야 하는 클래스의 종류가 여러개라면, 클래스를 바꿔낄 때마다 코드를 수정해줘야 한다.
그렇다면, 아래처럼 코드를 바꾸게 된다면 어떨까? 먼저, 다른 클래스를 의존해야 되는 A 클래스의 코드부터 수정해 보자.

~~~
public class A{

  private final B b; // 단일 클래스가 아닌, 여러 클래스를 의존시킨 인터페이스 B의 객체를 멤버로 선언한다. (인터페이스 B는 아래 코드에서 새로 선언한다.)

  public A(B b){ // 최중요 코드 1. 클래스의 생성자 패러미터로, 단일 클래스가 아닌 여러 클래스를 구현시킨 인터페이스를 받아온다. (**단, 실제 Main 메소드에서는 인터페이스가 아닌, B를 구현 중인 클래스 B1이나 B2의 객체가 들어갈 것이다!!)
    this.b = b; // 최중요 코드 2. 클래스 내부에서 직접 객체를 생성하지 않고, 생성자 패러미터로 받아온 인터페이스를 구현 중인 클래스의 객체를 인터페이스 멤버에 집어넣는다.
  }

  public void CallB(){
    b.print(); // 생성자 패러미터로 받아온 클래스 객체(위 생성자에서 B를 구현 중인 클래스 객체 B1이나 B2가 될 것이다.)의 메소드를 실행한다.
  }
}
~~~

그 다음, 비슷한 메소드 구성을 가지는 클래스 B1과 B2 클래스를 묶을 InterFace B를 만든 후 B1과 B2에 각각 구현시켜 보자.

~~~

//인터페이스 B를 선언 후, B1과 B2에서 사용할 메소드인 print를 선언

public interface B {
  public print();
}

//위의 B1과 B2 클래스의 코드를 B 인터페이스로 구현시키게끔 수정한다.

public class B1 implements B{ // 클래스 선언부에 인터페이스를 구현하겠다는 'implements' 명령어와 그 대상인 인터페이스 B를 지정
  public void print(){
    system.out.println("B1 클래스에 의존 중입니다.")
  }
}

public class B2 implements B{
  public void print(){
    system.out.println("B2 클래스에 의존 중입니다.")
  }
}

~~~

위 코드처럼 코드를 수정한다면, Main 메소드에서는 어떤 변화가 생길까?

~~~
public class Main{
  public static void main(String[] args) {
          B1 b1 = new B1();  // A가 의존할 클래스인 B1의 객체를 먼저 생성한다.
          A a = new A(b1);  // A 클래스 내부에서 의존하는 클래스의 객체를 직접 생성하지 않고, 생성자를 통해 의존할 클래스의 객체를 전해준다.
          a.CallB(); // a 객체 생성 시 전달받은 b1 객체의 print(); 메소드를 실행한다.
      }
}
~~~

위와 같이 A 클래스의 구조와 Main 메소드를 변경했다면, A가 의존하는 클래스를 B1에서 B2로 교체해야 할 경우 코드가 어떻게 바뀔까?

~~~
public class Main{
  public static void main(String[] args) {
          B2 b2 = new B2();  // A가 의존할 클래스를 B1에서 B2로 교체해야 하므로 객체를 B2 객체로 생성한다.
          A a = new A(b2);  // A 클래스 내부에서 의존하는 클래스 객체를 b1에서 b2로 교체했다.
          a.CallB(); // a 객체 생성 시 전달받은 객체가 b1에서 b2로 교체되었으므로, B2 클래스의 print(); 메소드가 실행된다. //"B2 객체에 의존하고 있습니다."
      }
}
~~~

A 클래스에서 생긴 변화를 간략히 정리하면, A 클래스 내부에서 의존하는 B 클래스의 객체 등을 직접 생성하지 않고 A 클래스의 생성자를 통해 객체를 생성하는 순간 패러미터로 B 클래스를 전달받게 되었다.
B 클래스에서 생긴 변화를 간략히 정리하면, 서로 비슷한 작동을 하는 B1, B2 클래스를 각각 만든 후, 인터페이스 B를 만들어 둘을 묶어주게 되었다.
두 변화가 생긴 후, Main 메소드에서는 A가 B 계열 클래스를 의존해야 할 경우, 생성자의 패러미터로 B1이나 B2 객체를 집어넣는 방식으로 의존할 수 있게 되었다.

이러한 변화의 가장 큰 장점은, A 클래스에서 B1이나 B2 등 의존해야 할 클래스를 변경해야 될 경우에도 A 클래스의 코드를 수정할 필요가 없다는 것이다.
이렇게 한 클래스가 다른 클래스를 의존할 때, 클래스 내부에서 의존하지 않고 외부에서 의존할 클래스를 지정하여 객체를 생성하는 것을 의존성 주입이라고 한다.

의존성 주입을 사용하면 처음에 이야기했던 '강하게 의존하는' 상황이 줄어들게 되므로 보다 객체지향적 프로그래밍에 가까워진다는 장점이 있다.
즉, 코드를 보다 세세하게 쪼개고 기능을 세분화시킬 수 있게 된다. 상황에 맞게 쪼갠 기능들을 결합시켜 사용하면 클래스 간의 책임이 명확해져 유지보수 또한 쉬워지게 될 것이다.

하지만 코드를 세세하게 쪼갠다는 것은 클래스 개수가 계속해서 늘어난다는 것이고, 체계적인 코드를 작성해야 하기 때문에 개발 속도가 늦어진다는 단점 또한 생겨난다.
그럼에도 의존성 주입은 MVC 패턴 내에서 각자의 역할을 명확히 나누는 클래스들끼리의 원활한 연계를 이룰 수 있는 기술이기 때문에 익히는 것이 좋을 것이다.

아래는 서로 의존하는 A, B 클래스의 의존 관계와 의존성 주입을 보다 명시적으로 수행하는 클래스이자 패턴인 'Assembler' 의 활용 예시이다.

~~~

import A;
import B;
import B1;
import B2;

public class Assembler{

  private A a;
  private B b;

  public Assembler(){
  b = new B1(); // B1이나 B2 객체를 갈아끼울 경우 여기서 수정!!
  a = new A(b); 
  }

  public A getA(){
  return a;
  }

}

~~~



실제로 스프링에서도 이러한 의존성 주입을 보다 매끄럽게 진행할 수 있도록 지원해주기도 하

스프링 어노테이션을 통한 객체 주입 이론과 객체 조립기 패턴에 대해서 내일 작성하기
