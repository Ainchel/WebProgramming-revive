# 데이터베이스란 무엇일까? (14페이지 ~ 16페이지) 진행 중

데이터베이스란 여러 사람이 공유할 목적을 가지고 논리적으로 연관된 데이터를 모아 통합 관리할 수 있도록 일정한 형태로 저장한 것을 의미한다.
데이터베이스의 가장 큰 목적은 중복 데이터를 최소화하여 조직의 목적에 맞게 효율적으로 관리하는 것이다.

데이터베이스의 정의는 ISOS로 표현된다고 한다. 필요할 경우 조사해 보도록 하자.
데이터베이스의 시스템은 R1C3으로 표현된다고 한다. 필요할 경우 조사해 보도록 하자.

데이터베이스를 사용할 경우, 데이터를 입력, 수정, 삭제하는 등의 기능을 제공하는 데이터베이스 관리 시스템을 별도로 사용해야 한다.
데이터베이스 관리 시스템을 DBMS라고 하며, 이는 DB와 명확히 구분되는 개념이다.

# 데이터베이스의 종류 알아보기 (17페이지 ~ 25페이지) 진행 중

1. 계층형 데이터베이스 : 데이터 사이에 부모와 자식 관계(트리 구조)가 적용되는 데이터베이스이다. 상위 레코드 아래에 하위 레코드가 있는 구조라고 한다. 하지만 데이터 중복이 발생하기 쉽고 추후 프로세스 변경이 어려워 현재는 사용하지 않는다고 한다.

**레코드란? 데이터베이스의 테이블 내에 저장되어 있는 값들의 모임을 말한다. 행(row) 또는 튜플(tuple)이라고도 한다.

2. 네트워크형 데이터베이스 : 데이터를 노드로 표현한 모델이다. 네트워크형 데이터베이스는 계층형 데이터베이스의 문제점(데이터 중복 문제, 상호 종속 관계)를 해결했으나 구조가 복잡하여 변경, 운영하기 어렵고 종속성 문제까지 있다고 한다.

   **노드란? 컴퓨터 네트워크를 이루는 기초 단위라고 한다. 각각 하나의 데이터를 의미한다고 생각하면 될 듯함.

각각의 노드는 주인, 혹은 멤버가 될 수 있는데 이러한 레코드 간의 관계를 일대다, 다대다 형식으로 표현할 수 있지만 종속성(어떤 레코드는 다른 레코드에 묶여야만 한다) 문제로 데이터베이스 구조 변경이 어렵다는 문제가 있다.

3. 키-값 데이터베이스 : NoSQL의 한 종류이다. 데이터를 키-값 형식으로 일대일 대응시켜 저장한다. 데이터 중복이 발생할 수 있지만 비정형 데이터 저장에 유리하다.

   **NoSQL이란? 비관계형 데이터베이스를 가리킨다. 기존의 관계형 데이터베이스의 한계를 극복할 수 있으며 문서, 그래프, 키-값, 검색 등 다양한 모델(형태)을 사용한다.

   **비정형 데이터란? 형식이 없는 데이터를 가리킨다. 텍스트, 음성, 영상과 같은 데이터는 데이터베이스의 정해진 규칙(형식)을 따르지 않는 형식이므로 비정형이라고 이해하자.

   키-값 데이터베이스는 단순한 객체에서 복잡한 집합체에 이르기까지 다양한 대상을 키와 값으로 사용할 수 있다. 또한 스키마(데이터베이스의 구조와 제약에 대한 정의/명세) 없이 작동하므로 데이터 구조를 정의할 필요가 없어 비정형 데이터도 쉽게 저장할 수 있다.

4. 관계형 데이터베이스 : 실무에서 가장 많이 사용되는 데이터베이스 종류이다. 데이터를 테이블 형태로 저장한다. 테이블은 열과 행으로 구성되어 있으며, 기본 키(primary key)가 행을 식별하고 데이터 또한 행 단위로 저장된다. 각 속성을 열에 나열한다.
예시) 이름, 전화번호, 이메일, 주소 등의 속성을 열로 나열하고, 이 열에 맞는 순서로 창명성, 000-0000-0000, xxxx@xxx.xxx, 대한민국 형식으로 저장된 한 데이터 뭉치가 행이다. 이러한 열과 행으로 데이터를 저장한 집합이 테이블이다.

엑셀과 형식이 비슷하다. 엑셀에 정리된 데이터의 집합이 시트인 것과 같이, 관계형 데이터베이스에서의 데이터 집합을 테이블이라고 한다. 이러한 테이블 간의 관계를 표현한 그림을 ERD라고 한다.

테이블 간에 관계를 가지게 되었을 때 가지는 가장 큰 장점은 테이블을 분리하여 목적에 맞는 데이터만 저장시킨 후, 서로를 참조 관계로 연결하여 데이터의 중복을 예방하고 더욱 쉽게 관리할 수 있다는 점이다.
예시) 회원의 주소를 저장한 데이터 테이블을 다른 테이블이 참조만 한다면, 데이터를 대규모로 변경할 필요 없이 주소를 저장한 테이블의 값만 수정하면 다른 테이블이 그 변경을 참조할 수 있을 것이다.

**RDMBS란? 관계형 데이터베이스를 관리할 시스템을 말한다. DBMS에서 앞에 관계형(R)만 붙인 것이라 생각하자.

# SQL이란 무엇일까? (26페이지 ~ 28페이지)

SQL은 Structured Query Language의 줄임말로, RDBMS의 데이터를 관리하는 데 사용하는 프로그래밍 언어이다. 데이터베이스 자체가 아님에 주의하자.
SQL은 표준 문법인 ANSI SQL을 따르면서 자사 제품(DBMS)에 특화된 문법이나 명세가 추가된다.

SQL 문법은 데이터 정의 언어(DDL), 데이터 조작 언어(DML), 데이터 제어 언어(DCL) 3가지로 나뉜다.
A. 데이터 정의 언어 : 데이터베이스를 정의하는 언어이다. 테이블의 스키마(데이터베이스의 구조와 제약에 대한 정의/명세)를 관리하는 역할을 한다.
B. 데이터 조작 언어 : 데이터베이스에 입력된 데이터를 조회/입력/수정/삭제하는 명령어를 가리킨다.
C. 데이터 제어 언어 : 데이터베이스에 접근하거나 객체에 권한을 부여하는 역할을 담당하는 명렁어를 가리킨다.

# SQL을 배워야 하는 이유(29페이지 ~ 32페이지)

과거에 비해 다루어야 하는 데이터의 종류가 다양해졌다. 음성, 이미지, 텍스트 등을 포함한 온갖 데이터의 활용도와 중요도 또한 높아졌으며 데이터를 처리/활용해 내가 원하는 통계를 낼 때 필요해질 것이다.

========================== 2장 : 나만의 SQL 실습 환경 만들기 - MySQL 및 MySQL 워크벤치의 설치/환경 설정/실행/사용법 등에 대해 적혀 있다. 나중에 실제 프로젝트 진행할 때 다시 찾아보도록 하자.

# 내 컴퓨터 환경 확인하기
윈도우즈와 macOS에서 적합한 SQL을 설치하기 위한 운영체제를 확인할 수 있다.

# MySQL 설치하기
윈도우즈와 macOS에서 MySQL 커뮤니티 에디션을 설치하는 방법을 확인할 수 있다.

# MySQL 워크벤치 설치하기
MySQL 워크벤치는 DB 설계자/개발자/관리자를 위한 통합된 시각적 도구라고 하며 서버 구성/사용자 관리/백업 등을 위한 데이터 모델링/SQL 개발/포괄적인 관리 도구를 제공한다고 한다.
더불어 윈도우즈/macOS에서 MySQL 워크벤치를 설치하는 방법을 확인할 수 있다.

# MySQL 워크벤치 사용법 알아보기(69 ~ 76페이지)
MySQL의 새로운 연결을 생성하는 방법(TCP/IP) 진행 중

# DDL과 DML 빠르게 맛보기 (78페이지 ~ 96페이지)

데이터 조작 언어(Data Manipulation Language)는 테이블에서 데이터를 조회(SELECT), 삽입(INSERT), 수정(UPDATE), 삭제(DELETE)하는 언어이다.

DML은 테이블을 대상으로 하므로 테이블이 반드시 필요하다. 그리고 이러한 테이블을 조작하는 언어를 DDL(Data Definition Language)이라고 한다.

DDL은 데이터베이스, 테이블, 뷰, 인덱스 등의 객체를 생성(CREATE), 삭제(DROP), 변경(ALTER)하는 데 사용한다.

CREATE : 데이터베이스를 생성한다. 기본 형식은 CREATE DATABASE [데이터베이스 이름] 이다. (대괄호 빼고 쓰기)

DROP : 데이터베이스를 삭제한다. 기본 형식은 DROP DATABASE [데이터베이스 이름] 이다.(대괄호 빼고 쓰기)

**데이터베이스를 생성할 때 제품이나 실행 프로그램에 따라 대소문자 구분 여부가 바뀐다. 운영체제에 따라서도 구분 여부가 바뀌므로 실제 업무에 들어갈 때 담당자에게 확인하는 등 대소문자 구분 및 참조에 신경 써야 한다.

테이블을 생성 및 삭제할 때에는 테이블이 데이터베이스에 속해 있으므로, 명령어를 통해 테이블이 위치할 데이터베이스를 선택 해줘야 한다. 그 경우 USE 명령어를 사용한다.

```
예시) CREATE DATABASE doitsql;
      USE doitsql;
```

테이블 생성 시, 공식 문서에서 제공하는 관련 문법은 모두 사용하지 않으므로 간단히 입력할 수 있다.

```
예시 1) CREATE TABLE 테이블 이름 (
[열 이름1 데이터 유형],
[열 이름2 데이터 유형],
(...이후 생략...)
)

예시 2) CREATE TABLE doit_create_table (
col_1 INT,
col_2 VARCHAR(50),
col_3 DATETIME
);

```

테이블도 데이터베이스와 마찬가지로 DROP문을 사용하여 삭제할 수 있다.

예시) DROP TABLE doit_create_table;

**DROP 명령어의 경우 데이터베이스와 테이블 모두 어떤 경고도 없이 즉시 해당 객체가 사라지므로 주의해야 한다.

현재 삭제하려는 테이블이 다른 테이블과 종속 관계에 있거나 상위 테이블일 경우 삭제할 수 없다고 한다.

INSERT문을 통해 데이터를 삽입할 수 있다. 기본 형식은 아래와 같다.

```
INSERT INTO 테이블명 ([열1, 열2 등 선택할 열]) VALUES ([열1에 적합한 값, 열2에 적합한 값 등...])

INSERT INTO doit_dml (col_1, col_2, col_3) VALUES (1, 'DoItSQL', '2023-01-01');
```

데이터를 삽입할 때 지정한 데이터 유형과 맞지 않으면 오류가 발생하므로 잘 확인하자.

위 형식에서 열 이름을 생략할 수도 있다. 하지만 열 이름을 생략하려면 VALUES문 뒤에 테이블의 열 순서와 개수를 정확히 맞춰 데이터를 채워야 한다. 일치하지 않을 경우 오류가 발생한다.

``` 열 이름 구간 (col_1, col_2, col_3)을 삭제해도 동작한다.
INSERT INTO doit_dml VALUES (1, 'DoItSQL', '2023-01-01');
```

또한 삽입하고자 하는 열만 소괄호 안에 명시할 경우 해당 열에만 데이터가 들어간다. 또한 위에서 열 순서와 개수만 맞으면 된다고 했으므로 입력 시 열 순서와 데이터 순서가 일치하게끔 순서를 바꿔서 입력시켜도 잘 작동한다.

여러 데이터를 한 번에 삽입하고 싶다면 INSERT 내 VALUES 구문에서 각 입력 데이터를 소괄호 묶음으로 구분시킬 수 있다. 이 경우 성능적으로도 유리하다.

```
INSERT INTO doit_dml(col_1, col_2, col_3)
VALUES (5,'데이터 입력5', '2023-01-03'), (6, '데이터 입력6', '2023-01-03'), (7, '데이터 입력7', '2023-01-03');
```

데이터를 조회하려면 SELECT 문을 사용한다. 기본 형식은 아래와 같다.

```
SELECT * FROM 테이블명

SELECT * FROM doit_dml;
```

**NULL은 어떤 값도 정의되지 않은 상태를 가리킨다. 테이블을 생성할 때, 각 열의 데이터를 정의할 때 NOT NULL을 붙이지 않는다면 NULL을 허용한다.

``` 각 열의 데이터를 정의할 때 NOT NULL을 선언하면 NULL값을 허용하지 않는다. 적지 않았을 경우 NULL을 허용한다.
예시) CREATE TABLE doit_create_table (
col_1 INT,
col_2 VARCHAR(50) NOT NULL

INSERT INTO doit_notnull (col_1) VALUES (1); //이 경우 col_2 값을 별도로 적지 않았으므로 NULL이 들어가야 하지만, NOT NULL로 선언되었으므로 에러가 발생한다.
);
```

테이블에 삽입되어 있는 데이터를 수정하려면 UPDATE 문을 사용한다. UPDATE 문의 기본 형식은 다음과 같다.

```
UPDATE 테이블이름 SET [](대괄호 빼고 입력)
WHERE [열 = 조건] (대괄호 뺴고 입력)
```

**UPDATE 문에서 WHERE 절을 생략할 수 있지만, 생략할 경우 테이블의 데이터 전체를 수정해 버리므로 사용할 떄 항상 주의해야 한다.

**WHERE절을 사용하지 않은 UPDATE(테이블 전체에 적용) 예시는 아래와 같다.

```
UPDATE doit_dml SET col_1 = col_1 + 10;
```

키 값을 사용하지 않을 경우 의도하지 않게 전체 데이터를 변경/삭제하지 않도록 방지하기 위해, WHERE 절 사용 시 안전 모드가 작동하기도 한다. 찾아보기.

위의 안전모드를 해제할 수도 있다. MySQL 워크벤치의 설정을 변경할 수도 있고, 쿼리를 사용하여 현재 세션에서만 비활성화시킬 수도 있다. 찾아보기.

입력된 데이터를 삭제하려면 DELETE 문을 사용한다. 기본 사용법은 아래와 같으며 UPDATE와 비슷하다.

```
DELETE FROM 테이블명 WHERE [열 = 조건](대괄호는 빼고 작성)
DELETE FROM doit_dml WHERE col_1 = 14;
```

DELETE 문을 사용하려면 반드시 FROM이 필요하다. 또한 WHERE를 사용하지 않으면 전체 데이터를 삭제하므로 항상 주의해야 한다.

```
DELETE FROM doit_dml;
```

대량의 데이터를 DELETE로 삭제할 경우 트랜잭션 로그 기록으로 인해 DB 성능에 문제가 발생할 수 있다. 테이블의 전체 데이터를 빠르게 삭제하고 싶다면 TRUNCATE 문을 사용한다.

**TRUNCATE 문은 롤백이 되지 않는다고 하자. 주의해서 사용하자.

```
TRUNCATE TABLE doit_dml;
```

MySQL에서의 주석 처리는 한 줄 주석, 여러 줄 주석으로 나뉜다. 주석 처리된 부분은 코드로 인식하지 않고 실행되지 않는다.

한줄 주석 : 하이픈 2개(--) 또는 해시 2개(##)로 적는다. 해당 줄을 주석 처리한다.

```
## 1줄 주석
-- 1줄 주석
```

여러 줄 주석 : 시작을 /*로, 끝을 */로 감산다.

```
/*
SELECT ~~~~
여러 줄 주석은 이렇게 적습니다
*/
```

**MySQL에서는 실행이 되는 주석을 사용할 수도 있다고 한다. 

```
/*! 실행시킬 주석 코드 작성 */
SELECT 1 /*! +1 */ <- 이 경우에는 다른 DBMS에서 실행하면 1이 되지만, MySQL에서는 2가 된다.
```

**또한 특정 버전을 지정에서만 실행되는 주석을 작성할 수도 있다. 이건 나중에 찾아보기.

# 데이터베이스 모델링 이해하기(97 페이지 ~ 104 페이지) 진행 중

데이터베이스 모델링이란 데이터베이스를 효율적으로 저장하기 위해 미리 설계하는 것을 일컫는다.

이는 곧 데이터베이스의 설계도를 만드는 것이므로 매우매우매우 중요한 일이다. 

데이터베이스 모델링은 곧 수집한 정보, 그것을 관리할 시스템을 시각적으로 표현하는 것이며, 즉 어떤 데이터가 존재하고 필요한지 분석하는 것이기도 하다.

데이터베이스 모델링이 잘못되면 성능이 저하되고 데이터베이스 확장 시 문제가 생긴다.

데이터베이스 모델링의 필요성과, 잘 된 데이터베이스 모델링의 장점은 아래와 같다.

A. DMBS 구축에 필요한 다양한 기술을 효율적으로 제시하고 적용시킬 수 있다.

B. 데이터베이스 설계 및 생성 속도와 효율성이 증가한다.

C. 조직의 데이터를 쉽게 문서화할 수 있고 관련 시스템 설계 시 일관성을 자유롭게 조절할 수 있다.

D. 업무/기술 조직 간 의사소통을 원활히 중재 할 수 있는 도구로 기능시킬 수 있다.

데이터 모델링은 개념적/논리적/물리적 이렇게 3가지로 나눌 수 있다.

A. 개념적 데이터 모델 : 실제 모델링보다는 요구 사항을 도출하고 범위와 설계를 정의하는 단계이다. 나중에 더 찾아보자.

B. 논리적 데이터 모델 : 개념적 데이터 모델 이후, 실제 DB 구성 전 데이터 간의 관계를 명확히 하고 가시화하는(ERD로 작업하는) 단계이다. 나중에 더 찾아보자.

C. 물리적 데이터 모델 : 논리적 데이터 모델 이후, 실제 DBMS와 언어를 사용해 데이터 필드 유형 등을 정의해 논리적 데이터 모델과 실제 DB 구현 사이를 잇는다.

좌측부터 우측 순으로 데이터베이스 구축 단계가 나뉜다. 좌측일 수록 추상화/단순화되어 있으며, 우측으로 갈 수록 구체화/세분화된다.

요구사항 분석 과정 -> 개념 모델링 과정 -> 논리 모델리 과정 -> 물리 모델링 과정 -> DB 구현 과정

릴레이션이란 두 엔티티 사이의 논리적인 관계를 일컫는다. 관계는 1:1 관계, 1:다 관계, 다:다 관계로 구분할 수 있다.

데이터베이스 정규화란, 목적에 맞게 테이블을 분리하고 중복 데이터를 제거하는 과정이다. 총 5단계로 구분되어 제1 정규화 ~ 제5 정규화까지 있으며 일반적으로는 제3 정규화까지 사용한다고 한다.

# 되새김 문제 (105페이지 ~ 106페이지) 나중에 풀어보기

===============================================4장 : SQL 기본 문법 익히기

# SELECT 문으로 데이터 조회하기 (108 페이지 ~ 113 페이지) 진행 중

SELECT문으로 데이터베이스에서 데이터를 조회할 수 있다. 시스템 성능에 많은 영향을 미치므로 주의해서 사용해야 한다.

자주 사용되는 SELECT문의 형태는 아래와 같다.

```
SELECT 열 - 조회할 데이터 열 선택
FROM 테이블 - 어느 테이블인지 선택
WHERE 조건 - 특정 값을 뽑아내기 위한 조건 입력
ORDRT BY 열 - 정렬 순서 선택
```

조회할 열을 여러개 선택하려면 쉼표로 구분하여 열을 적는다. 전체 열을 조회하려면 열 이름 대신 * 기호를 사용한다. 하지만 전체 열 조회는 자원을 아주 많이 먹으므로 정보를 최소화하는 습관을 들이는 게 좋다.

```
SELECT first_name, last_name
FROM customer;
```

MySQL 워크벤치에서는 Schemas 탭에서 열 정보를 확인할 수 있다.

# WHERE 절로 조건에 맞는 데이터 조회하기 (114 페이지 ~ 127 페이지) 진행 중

WHERE절을 활용하면 필요한 데이터만 조건을 걸어 조회할 수 있다. WHERE 절의 기본 형식은 아래와 같다.

```
SELECT 열 FROM 테이블 WHERE 열 = 조건값
SELECT * FROM customer WHERE first_name = 'MARIA';
```

WHERE 절에서는 다양한 비교 연산자를 사용하여 조건을 걸 수 있다. 비교 연산자는 나중에 확인해보자.

WHERE 절에서는 논리 연산자(참/거짓)을 판단하는 조건식도 사용할 수 있다. 나중에 확인해보자.

WHERE 절 사용 시 BETWEEN을 함께 사용하면 조회하는 값의 범위를 지정할 수 있다. 아래는 예시이다.

```
SELECT * FROM customer WHERE address_id BETWEEN 5 AND 10;
```

BETWEEN은 숫자, 날짜, 문자열 등의 사잇값을 전부 계산해 준다.

WHERE 절에서 AND, OR, NOT 등의 연산자도 사용할 수 있다. AND는 두 조건을 모두 만족하는 데이터를, OR는 두 조건 중 하나라도 만족하는 데이터를, NOT은 범위에 해당하지 않는 데이터를 조회한다.

여러 데이터를 조회하기 위해 OR를 여러번 사용하면 비효율적이다. 이럴 때에는 IN을 사용할 수 있다. 연산자를 하나만 작성하고, 쉼표를 통해 조건을 나열한다. 아래는 예시이다.

```
SELECT * FROM customer
WHERE first_name IN ('MARIA', 'LINDA', 'NANCY'); <- MARIA이거나, LINDA이거나, NANCY인 데이터를 가져온다.
```

OR이나 AND 연산자를 섞을 경우, AND를 먼저 끼고 묶어 원하는 데이터가 나오지 않을 수 있다. 이 경우 소괄호를 사용해 구문을 묶어주면 된다. 아래는 예시이다.
```
SELECT * FROM city WHERE country_id = 103 OR country_id = 86 AND city IN ('Cheju', 'Sunnyvale', 'Dallas') <- 이렇게 적으면 country_id = 86 이 뒤의 AND에 묶이게 된다.
SELECT * FROM city WHERE (country_id = 103 OR country_id = 86) AND city IN ('Cheju', 'Sunnyvale', 'Dallas') <- country_id끼리를 소괄호로 묶어 OR 연산자 범위를 적절하게 바꾸어주었다.
SELECT * FROM city WHERE country_id IN (103, 86) AND city IN ('Cheju', 'Sunnyvale', 'Dallas') <- 아니면 이렇게 IN으로 묶어줘도 된다.
```

NULL 값은 숫자 0이나 공백 같은 게 아닌, 데이터가 들어가 있지 않은 상태를 가리킨다. NULL은 = 연산자로 조회할 수 없다. IS NULL, IS NOT NULL로 조회해야 한다.

거꾸로 공백 값은 NULL이 아니라 = 연산자로 조회해야 하며, 따옴표 사이에 아무 것도 없는 '' 값으로 조회할 수 있다. 예시) WHERE address2 = '';

# ORDER BY 절로 데이터 정렬하기 (128 페이지 ~ 133 페이지) 진행 중

ORDER BY 절을 이용하면 조회한 데이터를 정렬시킬 수 있다. SELECT 문의 가장 마지막에 ORDER BY 절을 추가한다.

```
SELECT 열 FROM 테이블 WHERE 열 = 조건값 ORDER BY 열 ASC또는DESC (ASC는 오름차순, DESC는 내림차순이다)
SELECT * FROM customer ORDER BY last_name;
SELECT * FROM customer ORDER BY store_id, first_name;
```

특정 데이터 중에서 상위 N개의 데이터만 조회하고 싶을 경우 LIMIT을 사용한다. ORDER BY 뒤에 LIMIT 숫자 형식으로 개수를 지정한다.

```
SELECT * FROM customer ORDER BY store_id DESC, first_name ASC LIMIT 10;
```

LIMIT 뒤에 매개변수를 2개 입력하면 시작 값과 시작 값부터의 N개 데이터를 조회할 수 있다.

```
SELECT * FROM customer ORDER BY customer_id ASC, LIMIT 100, 10;
```

OFFSET을 지정하면 해당 수만큼 건너뛴 다음부터 지정한 개수를 센다. OFFSET은 반드시 LIMIT과 함께 사용한다.

```
SELECT * FROM customer ORDER BY customer_id ASC LIMIT 10 OFFSET 100;
```

# 와일드카드로 문자열 조회하기(134 페이지 ~ 144페이지) 진행 중

LIKE 구문을 사용하면 와일드카드로 지정한 패턴과 일치하는 문자열, 날짜, 시간 등을 조회할 수 있다. 기본 형식은 아래와 같다.

```
SELECT 열 FROM 테이블 WHERE 열 LIKE 와일드카드조건값
```

특정 문자열을 포함하는 문자열을 조회하는 와일드카드는 %를 사용한다. % 위치에 따라 특정 문자열이 포함된 문자열을 조회할 수 있다.

특정 문자열을 제외하고 조회하고 싶다면 NOT을 조합한다.

```
A% : A로 시작하는 모든 문자열
%A : A로 끝나는 모든 문자열
%A% : A가 포함된 모든 문자열

SELECT * FROM customer WHERE first_name LIKE 'A%'; << A로 시작하는 모든 문자열 조회
SELECT * FROM customer WHERE first_name NOT LIKE 'A%'; << A로 시작하지 않는 모든 문자열 조회
```

%는 예약어(프로그래밍 언어에서 문법으로 취급하는 문자)이므로 %를 문자 자체로 인식시키려면 ESCAPE를 사용해야 한다.

문자로 취급시키는 ESCAPE를 지정하려면 쿼리문 마지막에 ESCAPE를 붙인다. #를 ESCAPE로 지정하려면 문자로 취급하려면 ESCAPE를 '#' 를 붙여준다.

```
SELECT * FROM CTE WHERE col_1 LIKE '%#%%' ESCAPE '#'; << 이 경우 2번째 %는 문자로 인식된다. 처음과 마지막 %는 예약어로 인식된다.
```

특정 문자열에 길이까지 지정하려면 _를 사용한다. %와_를 섞으면 복잡한 문자열 데이터를 조회할 수 있다. 

```
A_ : A로 시작하는 2글자짜리 문자열
_A : A로 끝나는 2글자짜리 문자열
_A_ : 중간에 A가 들어가는 3글자짜리 문자열

SELECT * FROM customer WHERE first_name LIKE 'A_';
SELECT * FROM customer WHERE first_name LIKE '_____'; << _만 사용하면 해당 글자수의 문자열만 자동으로 찾는다. 이건 5개짜리.
```

정규 표현식을 의미하는 REGEXP를 사용하면 더 다양한 방법으로 문자열을 검색할 수 있다. 나중에 찾아보자.

# GROUP BY 절로 데이터 묶기(145 페이지 ~ 153 페이지)

데이터를 그룹화할 떄에는 GROUP BY를 사용한다. 그룹화는 특정 연산에 앞서 연산할 대상을 지정하거나, 현재 테이블에 들어가있는 각 행의 데이터 종류(즉 열에 어떤 값들이 지정되어 있는지)를 확인하는 데 사용할 수 있다.

```
SELECT special_features FROM film GROUP BY special_features;
```

COUNT 함수를 사용하면 그룹화시킨 데이터 항목들의 개수를 세어볼 수 있다.

```
SELECT special_features, COUNT(*) AS cnt FROM film GROUP BY special_features; << 이러면 cnt라는 이름의 열로 각 데이터 개수를 표시해준다.
```

GROUP BY 구문을 사용할 경우, SELECT로 지정한 열들을 반드시 GROUP BY에도 적어줘야 한다(규칙처럼 생각하기). 기준이 될 열이 필요하기 때문이라고 한다. (지금은 잘 모르겠어서 나중에 더 찾아보기)

GROUP BY로 그룹화한 데이터를 필터링 하려면 HAVING 절을 사용해야 한다. HAVING 절은 SELECT로 조회한 열, GROUP BY로 그룹화한 열에만 필터링을 적용할 수 있다. 그룹화하지 않으면 오류가 발생한다.

```
SELECT special_features, rating FROM film
GROUP BY spcial_features, rating
HAVING rating = 'G';
```

GROUP BY 절을 사용하지 않고 중복 데이터를 제거하고 싶다면 DISTINCT를 사용할 수 있다.

```
SELECT DISTINCT special_features, rating FROM film;
```

# 테이블 생성 및 조작하기 (154 ~ 164페이지)

AUTO_INCREMENT를 적용하면 해당 열은 1, 또는 사용자가 정의한 값만큼 자동으로 값을 증가시키며 데이터가 입력된다.

AUTO INCREMENT가 설정된 열에는 현재 자동 입력보다 크거나 같은 값을 입력해도 값이 들어가며, 증가값은 그 들어간 값에서 이어서 진행된다. 예시) 3까지 진행된 자동값의 다음 열에 7을 넣으면, 그 다음 자동값은 8부터 들어간다.

```
CREATE TABLE dout_increment (
col_1 INT AUTO_INCREMENT PRIMARY KEY, << INSERT 시 이 열은 값을 입력하지 않아도 자동으로 1씩 증가된 숫자가 들어간다.
);
```

AUTO INCREMENT의 시작값을 변경하려면 ALTER 명령어를 통해 테이블에 적용된 AUTO_INCREMENT의 값을 변경한다.

```
ALTER TABLE doit_increment AUTO_INCREMENT=100;
```

AUTO INCREMENT의 자동 증가값을 변경하려면 SET 명령어를 사용한다. 이 변경을 하고 나면, 첫 데이터의 증가 이후인 2번째 증가부터 증가값이 변경되어 적용된다.

```
SET @@AUTO_INCREMENT_INCREMENT = 5;
```

INSERT INTO와 SELECT를 통해 데이터 조회 결과를 다른 테이블에 입력할 수 있다. 쿼리가 기므로 필요 시 나중에 찾아보자.

데이터 조회 결과를 아예 새로운 테이블에 저장할 수도 있다. CREATE TABLE을 할 때 사용해 열 이름 대신 AS와 SELECT 문을 이용하면 된다.

```
CREATE TABLE doit_select_new AS (SELECT * FROM doit_insert_select_from);
```

관계형 데이터베이스의 부모-자식 테이블 관계에서, 부모 테이블에 없는 데이터가 자식 테이블에 있을 수 없다.

이는 데이터의 무결성을 위한 것이다. 테이블의 종속 관계를 만드는 외래 키가 있다면 데이터 또는 테이블 삭제에 실패할 수 있다.

자식 테이블에 데이터를 입력하려 할 때 부모 테이블에 해당 데이터가 없는 경우 에러가 발생한다. 이럴 경우 부모 테이블에 데이터를 먼저 입력해줘야 한다.

부모 테이블의 데이터를 삭제하려 하면 외래키 때문에 오류가 발생한다. 이럴 경우 자식 테이블의 데이터를 먼저 삭제해야 한다.

외래키로 부모-자식 관계가 된 두 테이블을 삭제하려면 기본적으로 자식 테이블 -> 부모 테이블 순서로 삭제해야 한다. 이 제약 없이 부모 테이블을 삭제할 수도 있으며 이 방법은 나중에 찾아보자.

SET 문을 통해 외래키 설정을 임시로 ON/OFF시킬 수도 있다. 

```
SET FOREIGN_KEY_CHECKS=0 혹은 1 << 0일 때 외래키 비활성, 1일 때 활성
```

# MySQL의 데이터 유형 정리하기 (165 페이지 ~ 176 페이지) 진행 중

MySQL은 숫자형, 문자형, 날짜형, 지리형, 공간형 등 다양한 데이터 유형을 제공한다. 그 중에서도 숫자형, 문자형, 날짜형에 대해 자세히 알아본다.

숫자형 : 정수, 실수 등의 숫자로 된 데이터 유형이다. SIGNED와 UNSIGNED로 나뉘어 저장 값 범위가 다르다. 목록은 아래와 같으므로 범위 값이 궁금하면 필요하면 추가로 찾아보자.

```
TINYINT : 1바이트
SMALLINT : 2바이트
MEDIUMINT : 3바이트
INT : 4바이트. << 일반적으로 많이 사용된다.
BIGINT : 8바이트 << 일반적으로 많이 사용된다.
```

실수형 : 고정 소수점과 부동 소수점 형식을 사용한다. 부동 소수점은 유효 범위 외의 값은 보장되지 않는다.

```
FLOAT(n) : 부동 소수점. 기본 4바이트. 정밀도가 명시되면 최대 8바이트.
DOUBLE : 부동 소수점. 8바이트
DECIMAL : 고정 소수점. 5 ~ 17바이트. 
NUMERIC : 고정 소수점. 5 ~ 17바이트.
```

숫자형 데이터를 사용할 때에는 형 변환에 주의해야 한다. 자동 형변환은 정의된 프로세스에 따라 수행된다.

문자형의 경우 데이터의 길이가 고정이냐 가변이냐에 따라 다른 유형 데이터를 사용해야 한다. 2~3바이트 내에서 글자 수를 예측할 수 없다면 용량을 넉넉히 잡은 CHAR를 자주 사용한다고 한다.

```
CHAR : 길이가 고정되어 있을 때 사용한다. (예시 - 주민등록번호는 14자리 고정임)
VARCHAR : 길이를 예측할 수 없지만 최대 글자 수를 예측할 수 있을 때 사용한다.
```

그 외 문자형 데이터 유형들이 169페이지에 기록되어 있으니 필요하면 찾아보자.

MySQL의 CHAR형과 VARCHAR형 뒤에 붙이는 숫자값은 문자열의 문자 개수를 나타낸다. 즉 데이터의 크기가 아니므로 유의해야 한다.

아래는 문자 별로 차지하는 저장공간의 크기이다. 더 자세한 내용은 '인코딩 형식' 을 찾아보면 알 수 있다고 한다.

```
아스키 문자 : 1바이트
알파벳 문자 : 2바이트
BMP 문자 : 3바이트 (찾아보기)
SMP, SIP 문자 등 : 4바이트
```

**유니코드란? 문자 데이터를 관리할 때 국가별 언어에 할당된 코드를 통일하기 위해 탄생한 인코딩 방법이다.

**MySQL의 한 행에 들어가는 데이터들의 총합은 64KB를 넘을 수 없으므로 유의하자.

문자형을 배울 때 문자 집합도 반드시 알아야 한다. 보통 utf8mb4를 사용한다고 한다. 책에서는 왜 설명 안해주는지 모르겠지만 나중에 찾아보도록 하자.

콜레이션은 문자열 데이터가 담긴 열을 비교하거나 정렬하기 위해 정한 규칙이다. 한글, 영어, 대소문자 등의 구분 우선순위를 정할 수 있다.

날짜/시간형은 날짜 또는 시간만 저장하거나 둘 다 함께 저장하는 데이터 유형이다. 어떤 형태이냐에 따라 크기와 형식이 조금씩 다르다.

```
TIME : 3~6바이트. HH:MM:SS(시분초) 형태의 데이터에 사용된다.
DATE : 3바이트. YYYY-MM-DD(연월일) 형태이다.
DATETIME : 5~8바이트. YYYY-MM-DD hh:mm:ss 형태로, 날짜와 시간을 모두 담는다.
TIMESTAMP : 4~7바이트. 날짜와 시간 모두를 포함하는 DATETIME과 비슷하지만, 1970년 1월 1일부터 2038년 1월 19일까지만 담긴다.
```

문자형과 날짜형끼리도 형 변환을 할 수 있다. 176 페이지의 표를 참고하자.

# 되새김 문제(177페이지 ~ 178페이지) : 나중에 풀어보자.

==============================================================5장 : 조인으로 두 테이블 묶기
