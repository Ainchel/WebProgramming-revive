# 들어가며 (26 ~ 28페이지) : 이 책을 왜 썼는지, 읽는 데 어떤 것들이 필요한지 나와있어서 정리함

JPA를 이해하려면 아래 목록에 있는 기술에 대한 기초적인 이해가 필요하다.
 자바 언어와 JDBC를 사용한 데이터베이스 프로그래밍, 그리고 객체지향 프로그래밍과 관계형 데이터베이스에 대한 
A. JAVA
B. JDBC를 사용한 데이터베이스 프로그래밍
C. 객체지향 프로그래밍
D. 관계형 데이터베이스
E. 웹 개발과 스프링 프레임워크
F. JUnit
G. 메이븐

JPA는 크게 객체와 테이블을 매핑하는 설계, 그리고 설계한 모델을 사용하는 부분으로 나뉜다.

1~9장은 이론 편이다. 이론에 대해서 집중적으로 공부할 것 같다.

JPA를 사용하면 개발 생산성과 유지보수가 좋아지고 코드 품질과 테스트에 더 많은 시간을 할애할 수 있다.

==========================================================1장 : JPA 소개

JDBC와 마이바티스(MyBatis), JdbcTemplate를 함께 사용해도, 기본적인 CRUD용 SQL은 반복해서 작성해야 했다. 이는 매우 비생산적이고 확장성이 부족했다.

이를 해결하기 위한 것은 객체 모델링이었으나, SQL만으로는 객체 모델링에 많은 어려움이 따랐다.

이러한 객체-데이터베이스 간 차이를 메워주는 것이 ORM(Object Relational Mapping)이다. JPA는 ORM의 자바 버전이라고 생각하자.

JPA는 반복적인 CRUD SQL을 처리해주며 조회 결과를 객체로 자동으로 매핑해준다. 또한 데이터베이스를 변경할 때 코드 수정이 간편하다.

# SQL을 직접 다룰 때 발생하는 문제점 (32페이지 ~ 39페이지)

자바로 개발하는 애플리케이션은 대부분 관계형 데이터베이스를 사용하고, 이 경우 JDBC를 통해 SQL을 다룬다.

이 경우 자바-DB 간 상호작용은 다음과 같이 이루어질 것이다.

A. 데이터 조회에 필요한 SQL을 작성한다.
B. JDBC를 사용해서 SQL을 실행시킨다.
C. 조회 결과를 자바 클래스 객체로 매핑한다.

위 결과를 거쳐 조회한 자바 클래스 객체를 자바 컬렉션에 보관할 경우, 개발자는 SQL과 JDBC를 사용해 데이터를 객체로 변환하는 작업을 반드시 거쳐야 한다.

이러한 CRUD를 진행하려면 SQL과 JDBC API를 반복해야 한다.

위 과정에서 데이터 사양이 하나 추가될 경우 클래스, CRUD SQL, JDBC 객체를 모두 수정해야 한다.

또한 자바 단의 DAO에서 어떤 SQL을 사용하고 있는지 하나하나 확인해야 된다. 즉, 엔티티(비즈니스 요구사항을 위해 만들어진 객체)와의 의존관계가 너무나 강해진다.

위 상황에서 JPA를 사용할 경우, CRUD 과정에서 개발자가 직접 SQL을 작성하지 않고 JPA의 API를 활용하게 된다.

# 패러다임의 불일치 (40 ~ 53 페이지)

현대의 복잡한 애플리케이션은 대부분 객체지향 언어로 개발되고 있다.

자바에서 이렇게 다루고 있는 객체들을 데이터베이스에 저장해야 하는데, 데이터베이스에는 자바에서 다루는 객체지향적 기술이나 개념이 없다.

이는 애초에 자바와 관계형DB가 지향하는 목적이 서로 다르기 때문이다. 이를 패러다임 불일치 문제라고 한다.

이 둘의 불일치 문제는 개발자가 해결해야 하는데, 이 과정에서 많은 시간과 코드를 소비하게 된다.

예시) 자바의 상속 클래스 관계는 DB에서 온전히 구현되지 못해, 부모와 자식 클래스에 해당하는 두 테이블의 데이터를 따로따로 다루고 합쳐야만 한다.

## 이 경우 JPA를 사용하면 자바에서 상속된 클래스를 다루면 내부적으로 쿼리를 생성해 준다.

자바에서는 다른 객체와 연관관계를 가질 때 참조를 사용한다. 반면 테이블(DB)은 외래키를 사용해 연관관계를 만들고 조인을 사용해 조회한다.

이러한 차이 때문에 객체 쪽에서 DB에 맞춰 모양을 바꾸면 객체지향이 사라지고, 객체지향을 살릴 경우 DB에 저장하거나 조회하기가 어려워지는 이지선다에 걸린다.

## 이 경우 JPA를 사용하면 자바 객체에서 설정한 결과를 SQL로 변환해 준다. DB에서 다루는 외래키를 참조 관계로 변환하는 것 또한 처리해 준다.

또한, SQL을 직접 다룰 경우 SQL로의 의존성이 너무 커져 객체로 변환시킨 데이터를 어디까지 조회할 수 있는지 SQL을 직접 확인해야만 알 수 있다.

그렇다고 데이터베이스의 모든 데이터를 객체로 만들어 메모리에 올려두는 것은 현실성이 없으므로, 필요한 데이터만 뽑는 메소드를 수없이 만들어 사용해야 한다.

## 이 경우 JPA를 사용하면 지연 로딩 기능을 통해 데이터를 한번에 조회할지, 실제로 필요한 지점에 필요한 데이터만 조회할지 자유롭게 선택할 수 있다.

객체와 DB에서의 값 비교 방법에서도 차이가 있다. DB는 각 행의 키 값으로 구분하지만, 객체의 경우 ==(주소값 확인), .equals(들어간 값 확인)로 구분한다.

이때문에 DB에서 조회한 같은 데이터를 같은 인스턴스로(같은 주소값을 가진 객체로) 반환하는 것 또한 쉽지 않다.

## 이 경우 JPA를 사용하면 같은 트랜잭션일 때 같은 객체로 조회되는 것을 보장해 준다(한 번의 코드로 조회한 데이터라면, 주소값이 같은 객체로 반환해 준다.)

# JPA란 무엇인가? (54 ~ 59 페이지) 진행 중

JPA는 애플리케이션과 JDBC 사이에서 동작하는 ORM이다. ORM은 객체와 관계형 데이터베이스를 매핑해준다.

ORM의 장점은 객체와 DB를 자연스럽게 이어줌과 동시에 패러다임 불일치를 자동으로 해결해 준다는 것이다. 자바는 자바스럽게(객체지향에 맞게) 코딩하면 되고, DB는 DB스럽게 만들면 된다.

이러한 ORM 프레임워크로 많이 사용되는 것이 하이버네이트이다.

JPA의 장점을 정리하자면 아래와 같다.

A. 자바에서 객체를 다루는 것과 같이 JPA를 이용하면 CRUD SQL 작성과 JDBC API를 쓰는 과정이 자동으로 처리되어 생산성이 올라간다.
B. 엔티티(객체)에 필드를 추가하기만 하면 자동으로 관련 SQL, JDBC를 자동으로 수정해줘 유지보수가 간편해진다.
C. 패러다임 불일치 문제를 자동으로 처리해주어 개발자의 수고를 덜 수 있다.
D. 데이터베이스와의 통신 등에서 내부적으로 최적화를 진행하여 성능 면에서 우수하다.
E. 다른 데이터베이스를 사용하게 되어도 JPA를 거치면 변경이 수월하다.

# ORM에 대한 궁금증과 오해 (60 ~ 62 페이지). 별다른 내용 없어서 패스. 중요한 건 ORM은 객체지향과 관계형데이터베이스를 전제로 한 기술이라는 것.

===================================================2장 : JPA 시작(64 ~ 88페이지) - 설치 및 환경 설정 관련이므로 패스. 

===================================================3장 : 영속성 관리

# 엔티티 매니저 팩토리와 엔티티 매니저(90 ~ 91 페이지) 진행 중

JPA에서 엔티티와 테이블을 매핑한다고 했다. 이렇게 매핑된 엔티티를 실제 사용하는 데 엔티티 매니저를 거쳐야 한다.

엔티티 매니저는 엔티티를 저장/수정/삭제/조회하는 등 엔티티와 관련된 모든 일을 처리한다.

엔티티 매니저는 가상의 데이터베이스라고 생각하면 된다. 엔티티 매니저를 생성하려면 먼저 엔티티 매니저 팩토리를 생성해야 한다.

DB를 하나 쓰는 애플리케이션은 보통 EntityManagerFactory를 하나 생성한다. 

```
EntityManagerFactory emf = Persistence.createEntityManagerFactory("팩토리이름"); << 엔티티 매니저 팩토리 생성. 비용이 많이 든다고 함
EntityManager em = emf.createEntityManager(); << 엔티티 매니저 생성. 비용 거의 안 든다고 함
```

엔티티 매니저 팩토리에는 여러 스레드가 동시에 접근해도 되지만, 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 공유해선 안 된다.

EntityManagerFactory를 생성하면 보통 커넥션풀도 같이 생성한다.

# 영속성 컨테스트란? (92페이지)

JPA를 이해하는 데 가장 중요한 용어는 영속성 컨텍스트다. 이는 '엔티티를 영구 저장하는 환경' 을 말하며, 엔티티 매니저를 이용할 때 같이 사용된다.

영속성 컨테스트는 논리적인 개념에 가까우며 엔티티 매니저를 생성할 때 하나 만들어진다.

# 엔티티의 생명주기 (92 ~ 94 페이지)

엔티티에는 4가지 상태가 존재한다.

```
A. 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태
B. 영속 : 영속성 컨텍스트에 저장된 상태
C. 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
D. 삭제 : 삭제된 상태
```

비영속 상태는 엔티티 객체를 생성했지만 저장하지는 않은 상태로, 이 때 엔티티는 영속성 컨텍스트나 DB와는 전혀 관련이 없다.

영속 상태는 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장한 상태다. 이 때부터 엔티티는 영속성 컨텍스트를 통해 관리하게 된다. 또한 조회 중인 엔티티도 영속 상태이다.

준영속 상태는 영속 상태이던 엔티티를 영속성 컨텍스트가 관리하지 않게 되는 상태이다. 영속성 컨텍스트를 닫거나 초기화해도 그 엔티티는 준영속 상태가 된다.

삭제 상태는 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한 상태이다.

# 영속성 컨텍스트의 특징 (95 ~ 페이지) 진행 중

영속성 컨텍스트는 엔티티를 식별자 값(@Id를 통해 테이블의 기본 키와 매핑한 값) 으로 구분한다.

즉, 영속 상태의 엔티티는 반드시 식별자 값을 가지게 된다. 식별자 값이 없다면 예외가 발생한다.

영속성 컨텍스트에 저장된 엔티티는 트랜잭션이 커밋되는 순간 해당 엔티티를 DB에 반영한다. 이를 플러시(Flush)라 한다.

영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이를 1차 캐시라고 한다. 영속 상태의 엔티티는 모두 여기에 저장되며, Map 형식으로 @Id-엔티티 객체 형식으로 연결되어 있다.

1차 캐시에 들어간 상태의 엔티티는 아직 데이터베이스에 저장되지 않으며, 이곳에 데이터를 저장하고 조회하는 모든 기준은 데이터베이스의 기본 키 값과 연결되어 있는 식별자 값이다.

데이터를 조회하는 .find() 메소드는 호출 시 먼저 1차 캐시에서 엔티티를 찾아보고, 있다면 데이터베이스 조회 없이 불러와 사용한다. 만약 없다면 DB를 찾아가 조회한다.

영속성 컨텍스트 단에서 불러온 객체는 1차 캐시에서 불러온 같은 객체임으로 객체 동일성을 보장한다.

JPA는 트랜잭션이 커밋되는 순간 데이터베이스에 SQL을 쏘며, 그 이전까지는 컨텍스트 안에만 있는 상태이다.

엔티티 매니저는 트랜잭션 커밋 전까지 내부 쿼리 저장소에 쿼리들을 모아두었다 커밋 때 적용한다. 이를 쓰기 지연이라고 한다. 쿼리를 한 번에 전달하므로써 성능을 최적화할 수 있다고 한다.

SQL로 데이터를 수정하려면 수정 쿼리를 직접 작성해야 한다. 이는 비즈니스 로직이 SQL에 계속해서 의존해야만 하는(로직 돌아가는 걸 확인하려면 자꾸 쿼리문을 확인해야만 하는) 문제점을 낳는다.

JPA에서는 엔티티의 변경사항이 생겼을 경우, 해당 엔티티의 데이터를 변경만 해두면 DB에 자동으로 반영이 된다. 이를 변경 감지 기능이라고 한다.

변경 감지 기능은 영속성 컨텍스트에 보관할 때의 엔티티 데이터와, 플러시 시점(커밋 시점)의 엔티티 데이터를 비교하여 변경된 데이터를 플러시 시점에 UPDATE 시켜준다.

변경 감지 기능은 영속성 컨텍스트가 관리 중인 엔티티(즉 영속 상태)에만 적용된다. 비영속이나 준영속 상태의 엔티티에는 적용되지 않는다.

변경 감지 적용 시, 변경할 데이터만 UPDATE하지 않고 엔티티의 모든 필드를 UPDATE한다. 이는 쿼리의 재사용성(쿼리문 스타일 조회한 같은 데이터를 같은 인스턴스로(같은 주소값을 가진 객체로) 반환하는 것 또한 쉽지 않다.

## 이 경우 JPA를 사용하면 같은 트랜잭션일 때 같은 객체로 조회되는 것을 보장해 준다(한 번의 코드로 조회한 데이터라면, 주소값이 같은 객체로 반환해 준다.)

# JPA란 무엇인가? (54 ~ 59 페이지) 진행 중

JPA는 애플리케이션과 JDBC 사이에서 동작하는 ORM이다. ORM은 객체와 관계형 데이터베이스를 매핑해준다.

ORM의 장점은 객체와 DB를 자연스럽게 이어줌과 동시에 패러다임 불일치를 자동으로 해결해 준다는 것이다. 자바는 자바스럽게(객체지향에 맞게) 코딩하면 되고, DB는 DB스럽게 만들면 된다.

이러한 ORM 프레임워크로 많이 사용되는 것이 하이버네이트이다.

JPA의 장점을 정리하자면 아래와 같다.

A. 자바에서 객체를 다루는 것과 같이 JPA를 이용하면 CRUD SQL 작성과 JDBC API를 쓰는 과정이 자동으로 처리되어 생산성이 올라간다.
B. 엔티티(객체)에 필드를 추가하기만 하면 자동으로 관련 SQL, JDBC를 자동으로 수정해줘 유지보수가 간편해진다.
C. 패러다임 불일치 문제를 자동으로 처리해주어 개발자의 수고를 덜 수 있다.
D. 데이터베이스와의 통신 등에서 내부적으로 최적화를 진행하여 성능 면에서 우수하다.
E. 다른 데이터베이스를 사용하게 되어도 JPA를 거치면 변경이 수월하다.

# ORM에 대한 궁금증과 오해 (60 ~ 62 페이지). 별다른 내용 없어서 패스. 중요한 건 ORM은 객체지향과 관계형데이터베이스를 전제로 한 기술이라는 것.

===================================================2장 : JPA 시작(64 ~ 88페이지) - 설치 및 환경 설정 관련이므로 패스. 

===================================================3장 : 영속성 관리

# 엔티티 매니저 팩토리와 엔티티 매니저(90 ~ 91 페이지) 진행 중

JPA에서 엔티티와 테이블을 매핑한다고 했다. 이렇게 매핑된 엔티티를 실제 사용하는 데 엔티티 매니저를 거쳐야 한다.

엔티티 매니저는 엔티티를 저장/수정/삭제/조회하는 등 엔티티와 관련된 모든 일을 처리한다.

엔티티 매니저는 가상의 데이터베이스라고 생각하면 된다. 엔티티 매니저를 생성하려면 먼저 엔티티 매니저 팩토리를 생성해야 한다.

DB를 하나 쓰는 애플리케이션은 보통 EntityManagerFactory를 하나 생성한다. 

```
EntityManagerFactory emf = Persistence.createEntityManagerFactory("팩토리이름"); << 엔티티 매니저 팩토리 생성. 비용이 많이 든다고 함
EntityManager em = emf.createEntityManager(); << 엔티티 매니저 생성. 비용 거의 안 든다고 함
```

엔티티 매니저 팩토리에는 여러 스레드가 동시에 접근해도 되지만, 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 공유해선 안 된다.

EntityManagerFactory를 생성하면 보통 커넥션풀도 같이 생성한다.

# 영속성 컨테스트란? (92페이지)

JPA를 이해하는 데 가장 중요한 용어는 영속성 컨텍스트다. 이는 '엔티티를 영구 저장하는 환경' 을 말하며, 엔티티 매니저를 이용할 때 같이 사용된다.

영속성 컨테스트는 논리적인 개념에 가까우며 엔티티 매니저를 생성할 때 하나 만들어진다.

# 엔티티의 생명주기 (92 ~ 94 페이지)

엔티티에는 4가지 상태가 존재한다.

```
A. 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태
B. 영속 : 영속성 컨텍스트에 저장된 상태
C. 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
D. 삭제 : 삭제된 상태
```

비영속 상태는 엔티티 객체를 생성했지만 저장하지는 않은 상태로, 이 때 엔티티는 영속성 컨텍스트나 DB와는 전혀 관련이 없다.

영속 상태는 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장한 상태다. 이 때부터 엔티티는 영속성 컨텍스트를 통해 관리하게 된다. 또한 조회 중인 엔티티도 영속 상태이다.

준영속 상태는 영속 상태이던 엔티티를 영속성 컨텍스트가 관리하지 않게 되는 상태이다. 영속성 컨텍스트를 닫거나 초기화해도 그 엔티티는 준영속 상태가 된다.

삭제 상태는 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한 상태이다.

# 영속성 컨텍스트의 특징 (95 ~ 106 페이지) 진행 중

영속성 컨텍스트는 엔티티를 식별자 값(@Id를 통해 테이블의 기본 키와 매핑한 값) 으로 구분한다.

즉, 영속 상태의 엔티티는 반드시 식별자 값을 가지게 된다. 식별자 값이 없다면 예외가 발생한다.

영속성 컨텍스트에 저장된 엔티티는 트랜잭션이 커밋되는 순간 해당 엔티티를 DB에 반영한다. 이를 플러시(Flush)라 한다.

영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이를 1차 캐시라고 한다. 영속 상태의 엔티티는 모두 여기에 저장되며, Map 형식으로 @Id-엔티티 객체 형식으로 연결되어 있다.

1차 캐시에 들어간 상태의 엔티티는 아직 데이터베이스에 저장되지 않으며, 이곳에 데이터를 저장하고 조회하는 모든 기준은 데이터베이스의 기본 키 값과 연결되어 있는 식별자 값이다.

데이터를 조회하는 .find() 메소드는 호출 시 먼저 1차 캐시에서 엔티티를 찾아보고, 있다면 데이터베이스 조회 없이 불러와 사용한다. 만약 없다면 DB를 찾아가 조회한다.

영속성 컨텍스트 단에서 불러온 객체는 1차 캐시에서 불러온 같은 객체임으로 객체 동일성을 보장한다.

JPA는 트랜잭션이 커밋되는 순간 데이터베이스에 SQL을 쏘며, 그 이전까지는 컨텍스트 안에만 있는 상태이다.

엔티티 매니저는 트랜잭션 커밋 전까지 내부 쿼리 저장소에 쿼리들을 모아두었다 커밋 때 적용한다. 이를 쓰기 지연이라고 한다. 쿼리를 한 번에 전달하므로써 성능을 최적화할 수 있다고 한다.

SQL로 데이터를 수정하려면 수정 쿼리를 직접 작성해야 한다. 이는 비즈니스 로직이 SQL에 계속해서 의존해야만 하는(로직 돌아가는 걸 확인하려면 자꾸 쿼리문을 확인해야만 하는) 문제점을 낳는다.

JPA에서는 엔티티의 변경사항이 생겼을 경우, 해당 엔티티의 데이터를 변경만 해두면 DB에 자동으로 반영이 된다. 이를 변경 감지 기능이라고 한다.

변경 감지 기능은 영속성 컨텍스트에 보관할 때의 엔티티 데이터와, 플러시 시점(커밋 시점)의 엔티티 데이터를 비교하여 변경된 데이터를 플러시 시점에 UPDATE 시켜준다.

변경 감지 기능은 영속성 컨텍스트가 관리 중인 엔티티(즉 영속 상태)에만 적용된다. 비영속이나 준영속 상태의 엔티티에는 적용되지 않는다.

변경 감지 적용 시, 변경할 데이터만 UPDATE하지 않고 엔티티의 모든 필드를 UPDATE한다. 이는 쿼리의 재사용성(쿼리문 스타일이 동일하므로)을 고려한 것이다.

확장 기능을 사용하면 동적으로 UPDATE하는 쿼리도 생성할 수 있다. @org.hibernate.annotations.DynamicUpdate 어노테이션 나중에 찾아보자.

엔티티를 삭제하는 .remove() 메소드를 사용하면 여태까지와 비슷하게 1차 캐시에 쿼리를 두었다가 플러시 시점에 적용시킨다. 엔티티는 메소드 호출 즉시 영속성 컨텍스트에서 제거된다.

# 플러시 (107 ~ 108 페이지) 진행 중

플러시는 영속성 컨텍스트에 저장된 각종 쿼리 및 변경 사항을 DB에 반영하는 단계이다.

플러시 시 변경 감지를 동작해 영속성 컨텍스트 내의 모든 엔티티를 스냅샷(컨텍스트 들어올 때의 엔티티 데이터 최초 상태)과 비교해 수정된 엔티티를 찾고, 그 후 쓰기 지연 SQL 저장소에 쿼리를 등록하고 전송한다.

영속성 컨텍스트를 플러시하는 방법은 아래 3가지이다.

```
A. em.flush()를 호출한다. JPA와 다른 프레임워크를 함꼐 사용하는 경우가 아니면 거의 사용되지 않는다고 한다.
B. 트랜잭션 커밋 시 자동으로 호출된다. JPA는 트랜잭션을 커밋할 경우 데이터베이스로의 반영을 위해 자동으로 플러시를 호출시킨다.
C. JPQL 쿼리 실행 시 자동으로 호출된다. 객체지향 쿼리를 호출할 경우 플러시가 자동으로 실행된다. 이는 쿼리 호출 떄 데이터베이스에 컨텍스트 변경이 반영되어 있어야 하기 때문이다.
```

** 식별자를 기준으로 데이터를 조회하는 find() 메소드를 호출할 때에는 플러시가 실행되지 않는다. 즉 컨텍스트 단계에만 있는 데이터들은 find로 조회할 수 없다.

엔티티 매니저를 통해 플러시 옵션을 지정할 수 있다. javax.persistence.FlushModeType 객체에 대해 한번 조사해 보자. 기본은 커밋이나 쿼리를 실행할 때 플러시한다.

** 플러시 시, 영속성 컨텍스트에 보관된 엔티티는 삭제되지 않는다.

# 준영속 (109 ~ 118페이지)

영속성 컨텍스트에서 관리하는 엔티티가 컨텍스트에서 분리된 상태를 준영속 상태라 한다. 따라서 영속 상태에서 사용하던 기능을 사용할 수 없게 된다.

방법은 아래 3가지가 있다.

```
A. .detach(entity) 메소드를 사용해 특정 엔티티만 준영속 상태로 전환한다.
B. .clear() 메소드를 사용해 영속성 컨텍스트를 초기화하여 전부 준영속 상태로 전환한다. 이는 영속성 컨텍스트를 제거하고 새로 만든 것과 같다.
C. .close() 메소드를 사용해 영속성 컨텍스트를 종료하여 전부 준영속 상태로 전환한다. 
```

영속 상태의 엔티티가 준영속 상태로 전환될 경우 컨텍스트 내에서의 해당 엔티티 정보가 제거되어 각종 기능들(1차 캐시, 쓰기 지연 SQL)을 사용할 수 없다. 데이터베이스로 반영도 되지 않는다.

준영속 상태의 엔티티의 특징은 아래와 같다.

```
A. 영속성 컨텍스트가 제공하는 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩을 포함한 기능이 동작하지 않는다.
B. 한 번 영속 상태였기 때문에 식별자 값을 반드시 가지고 있다.
C. 영속성 컨텍스트를 거쳐야 하는 지연 로딩 기능을 사용할 수 없다(A와 같은 내용)
```

준영속 상태의 엔티티를 다시 영속 상태로 돌리려면 병합 기능을 사용해야 한다. 엔티티 매니저의 merge() 메소드를 사용하면 준영속/비영속 상태의 엔티티를 영속 상태의 새로운 엔티티로 받아오게 된다.

merge() 메소드에 집어넣은 준영속 엔티티와, 반환 받은 새로운 영속 엔티티는 서로 다른 객체이므로 이전 엔티티는 사용하지 않아도 된다.

엔티티 매니저의 .contains(엔티티) 메소드를 사용하면 영속성 컨텍스트가 해당 엔티티를 영속 상태로 관리 중인지 확인할 수 있다.

# 정리 (119 페이지) 진행 중

학습한 내용을 정리하면 아래와 같다.

```
A. 영속성 컨텍스트를 사용하려면 엔티티 매니저 팩토리, 엔티티 매니저가 필요하다. 엔티티 매니저를 통해 영속성 컨텍스트에 접근한다.
B. 영속성 컨텍스트는 어플리케이션과 데이터베이스 사이에서 엔티티를 관리하는 가상의 데이터베이스 역할을 한다.
C. 영속성 컨텍스트를 통해 1차 캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기 지원, 변경 감지, 지연 로딩 등의 기능을 사용할 수 있다.
D. 영속성 컨텍스트의 플러시 기능(커밋 실행 시 작동)을 거쳐야 데이터베이스에 실제 데이터 CRUD가 반영된다.
E. 영속성 컨텍스트가 엔티티를 관리하고 있다면 영속 상태이며, 그렇지 않은 상태를 비영속/준영속 상태라 한다. 영속성 컨텍스트의 기능은 영속 상태에서만 사용할 수 있다.
```

===========================================================================4장 : 엔티티 매핑

JPA를 사용하는 데 가장 중요한 것은 엔티티와 테이블을 정확히 매핑하는 것이다. 이를 위해선 매핑 어노테이션을 숙지해야 한다.

아래는 대표적인 어노테이션이다.

```
객체-테이블 매핑 : @Entity, @Table
기본 키 매핑 : @Id
필드-컬럼 매핑 : @Column
연관관계 매핑 : @ManyToOne, @JoinColumn
```

# @Entity 어노테이션 (122~123 페이지)

JPA를 사용해서 테이블과 매핑시킬 클래스는 @Entity 어노테이션을 필수로 붙여야 한다. 이 어노테이션이 붙은 클래스는 JPA가 관리하는 엔티티가 된다.

@Entity 어노테이션을 사용할 클래스는 아래 규칙을 지켜야 한다.

```
A. 기본 생성자가 반드시 있어야 한다.
B. final, enum, interface, inner 클래스에는 사용할 수 없다.
C. 저장할 필드에 final을 사용하면 안 된다.
```

자바의 경우 생성자가 하나도 없으면 기본 생성자를 만들지만, 다른 생성자를 만들 경우 기본 생성자를 만들지 않으므로 직접 만들어야 한다.

# @Table 어노테이션 (123 ~ 124페이지) 진행 중

엔티티와 매핑할 테이블을 지정하려면 @Table 어노테이션을 사용한다. 생략할 경우 매핑한 엔티티 이름을 테이블 이름으로 사용한다고 한다. 하위 속성은 나중에 찾아보기.

# 다양한 매핑 사용 (124 ~ 125페이지) 코드 변경만 있으므로 넘어감

# 데이터베이스 스키마 자동 생성 (125 ~ 129 페이지) 진행 중

JPA에서는 클래스의 매핑 정보와 데이터베이스 방언을 통해 자바 단에서 엔티티만 만든 후 그에 맞게 테이블을 자동 생성시킬 수 있다. 데이터베이스 방언은 나중에 찾아보기.

스키마+테이블 자동 생성 기능을 사용하면 개발자가 테이블을 직접 생성하는 수고를 덜 수 있다.

또한, 자동 생성되는 구조를 통해 엔티티와 테이블이 어떻게 매핑되는지 쉽게 학습하고 이해할 수 있다.

자바의 카멜 표기법과 데이터베이스의 언더스코어 표기법이 서로 다르므로 이름 매핑 전략에 신경 써야 한다. ** 이러한 이름 매핑과 관련된 클래스 org.hibernate.cfg.ImprovedNamingStrategy 나중에 찾아보기.

# DDL 생성 기능 (129 ~ 130 페이지)

스키마 자동 생성을 통해 만들어지는 DDL에 제약조건을 추가시킬 수 있다. @Column과 @Table 어노테이션의 속성을 통해 이러한 제약을 추가시킬 수 있다.

# 기본 키 매핑(131 ~ 144 페이지)

애플리케이션에서 직접 할당하지 않은 값(MySQL의 AUTO_INCREMENT 같은 것들)을 기본 키로 사용하기 위해서는 아래 방법을 취해야 한다.

```
A. 애플리케이션에서 기본 키를 직접 할당한다.
B. IDENTITY, SEQUENCE, TABLE 같은 대리 키 사용 방식을 사용한다. << 데이터베이스마다 사용 가능한 것이 있고 불가능한 것이 있다.
```

기본 키를 직접 할당하려면 필드에 @Id 어노테이션을 사용하여 매핑할 필드를 지정하고, em.persist()로 엔티티를 저장하기 전에 해당 필드 값을 엔티티에 할당시켜둬야 한다.

개발자가 @Id를 쓰지 않고(기본 키를 직접 할당하지 않고) 값 생성을 맡기려면 IDENTITY를 사용한다. MySQL에서도 사용한다. @GeneratedValue 어노테이션과 함께 사용하므로 나중에 찾아보자.

**IDENTITY 식별자 생성은 쓰기 지연이 불가능하다. (식별자가 있어야 지연 쓰기를 하는데, IDENTITY는 데이터베이스에 저장하고 나서야 식별자가 구해지므로, em.persist()를 하는 순간 INSERT까지 들어가버리기 때문)

SEQUENCE 전략 - MySQL에서는 사용하지 않는다고 한다. 일단 패스 나중에 찾아보기

TABLE 전략도 나중에 찾아보기

그 외에 사용 중인 데이터베이스 방언에 따라 위의 전략 중 하나를 자동으로 선택해주는 AUTO 전략도 있다.

식별자 선택 전략을 위해 아래 조건은 기억해 두자.

``` 기본 키의 조건
A. NULL값은 허용하지 않는다.
B. 유일해야 한다
C. 변하지 않아야 한다.
```

```기본 키 선택 전략
A. 자연 키 : 비즈니스적으로 의미가 있는 키. 예시) 주민등록번호, 이메일, 전화번호
B. 대리 키 : 비즈니스적으로는 의미 없는 키. 예시) AUTO_INCREMENT 값, 오라클 시퀀스, 키 생성용 테이블
```

# 필드와 컬럼 매핑 : 레퍼런스 (145 ~ 페이지) 진행 중

필드와 컬럼을 매핑시켜주는 어노테이션을 정리하면 아래와 같다.

```
A. @Column : 컬럼을 매핑한다.
B. @Enumerated : 자바의 enum 타입을 매핑한다.
C. @Temporal : 날짜 타입을 매핑한다.
D. @Lob : BLOB, CLOB 타입을 매핑한다. << 이게 뭔데
E. @Transient : 특정 필드를 데이터베이스에 매핑하지 않는다.
F. @Access : JPA가 엔티티에 접근하는 방식을 지정한다.
```

@Column은 객체 필드를 테이블 컬럼에 매핑시킨다. 가장 많이 사용되며 기능도 많다.

주로 name, nullable 속성이 사용되며 나머지는 잘 사용되지 않는다고 한다. 그 외 속성들은 나중에 읽어보기. 아래는 "거의 사용하지 않음" 이라고 적히지 않은 속성들 정리.

```
nullable : null 값의 허용 여부를 설정한다. false로 설정하면 DDL로 not null 제약 조건을 추가해 준다.
unique : 한 컬럼에 유니크 제약 조건을 건다. 일반적으로는 한 컬럼에만 사용할 수 있는 듯함.
columnDefinition : 데이터베이스 컬럼 정보를 직접 줄 수 있다고 함. 뭔 소린지 모르겠으니 나중에 찾아보기.
length : 문자 길이 제약 조건을 건다. String 타입에만 사용한다.
precision, scale : 고정소수점?에서 전체 자릿수와 소수점 자릿수를 지정할 때 사용한다.
```

** @Column 어노테이션을 생략할 경우 변수형, 객체형에 따라 DDL이 알아서 변환된다.(변수형은 NULL을 못 넣으므로 not null 자동으로 들어가는 식) 이 때 변수형에 @Column을 사용하면 nullable = true가 기본으로 들어가므로 nullable=false를 따로 지정해주는 것이 안전하다.

@Enumerated는 enum 타입을 매핑할 때 사용한다. .ORDINAL, .STRING 등의 속성이 있으며 특징은 아래와 같다.

```
1. .ORDINAL : 지정한 enum  내 값의 순서들만 숫자로 저장한다. 데이터베이스에 저장되는 데이터 크기는 작지만, 저장된 enum의 순서를 변경할 수 없다. 기본 값이지만 주의해서 사용해야 한다.
2. .STRING : 지정한 enun 내 값을 문자열 형태 그대로 저장한다. 저장된 enum의 순서가 바뀌거나 추가되어도 안전하지만, 데이터베이스에 저장되는 데이터 크기가 상대적으로 크다. 이 쪽 사용을 권장한다고 한다.
```

@Temporal은 날짜 타입을 매핑할 때 사용한다. 속성으로 .DATE, .TIME, .TIMESTAMP가 있으며 데이터베이스의 각 타입(date, time, timestamp)과 매핑되며 반드시 지정해줘야 한다.

@Temporal을 생략할 경우 자바의 Date와 가장 유사한 timestamp로 자동 정의된다. MySQL은 datetime으로 변경된다고 한다.

@Lob은 데이터베이스 BLOB과 CLOB 타입과 매핑한다. 별도 속성은 없으며, 매핑시키는 필드 타입이 문자면 CLOB으로, 그 외에는 BLOB으로 매핑시킨다.

**BLOB과 CLOB이란? 대용량 데이터를 저장하는 데이터 타입으로, BLOB은 이미지, 동영상, 오디오, 문서 등의 파일을 저장하고 CLOB은 대용량의 텍스트 데이터(로그, 웹사이트 등)를 저장한다.

@Transient는 매핑을 아예 하지 않는다. 데이터베이스에 저장도 되지 않고 조회도 되지 않는다. 객체에 임시로 어떤 값을 보관하고 싶을 때 사용한다.

@Access는 엔티티 데이터에 접근하는 방식을 지정한다. 필드 접근과 프로퍼티 접근 방식이 있다.

```
필드 접근 : AccessType.FIELD 속성으로 지정한다. 필드에 직접 접근하며 private여도 접근할 수 있다. 
프로퍼티 접근 : AccessType.PROPERTY로 지정한다. 접근자(Getter)를 사용한다.
```

@Access를 설정하지 않으면 @Id 어노테이션이 적용된 위치를 기준(필드인지? 메소드(혹은 필드 외)인지?)를 체크해 접근 방식이 설정된다.

# 정리개발자가 @Id를 쓰지 않고(기본 키를 직접 할당하지 않고) 값 생성을 맡기려면 IDENTITY를 사용한다. MySQL에서도 사용한다. @GeneratedValue 어노테이션과 함께 사용하므로 나중에 찾아보자.

**IDENTITY 식별자 생성은 쓰기 지연이 불가능하다. (식별자가 있어야 지연 쓰기를 하는데, IDENTITY는 데이터베이스에 저장하고 나서야 식별자가 구해지므로, em.persist()를 하는 순간 INSERT까지 들어가버리기 때문)

SEQUENCE 전략 - MySQL에서는 사용하지 않는다고 한다. 일단 패스 나중에 찾아보기

TABLE 전략도 나중에 찾아보기

그 외에 사용 중인 데이터베이스 방언에 따라 위의 전략 중 하나를 자동으로 선택해주는 AUTO 전략도 있다.

식별자 선택 전략을 위해 아래 조건은 기억해 두자.

``` 기본 키의 조건
A. NULL값은 허용하지 않는다.
B. 유일해야 한다
C. 변하지 않아야 한다.
```

```기본 키 선택 전략
A. 자연 키 : 비즈니스적으로 의미가 있는 키. 예시) 주민등록번호, 이메일, 전화번호
B. 대리 키 : 비즈니스적으로는 의미 없는 키. 예시) AUTO_INCREMENT 값, 오라클 시퀀스, 키 생성용 테이블
```

# 필드와 컬럼 매핑 : 레퍼런스 (145 ~ 153 페이지) 진행 중

필드와 컬럼을 매핑시켜주는 어노테이션을 정리하면 아래와 같다.

```
A. @Column : 컬럼을 매핑한다.
B. @Enumerated : 자바의 enum 타입을 매핑한다.
C. @Temporal : 날짜 타입을 매핑한다.
D. @Lob : BLOB, CLOB 타입을 매핑한다. << 이게 뭔데
E. @Transient : 특정 필드를 데이터베이스에 매핑하지 않는다.
F. @Access : JPA가 엔티티에 접근하는 방식을 지정한다.
```

@Column은 객체 필드를 테이블 컬럼에 매핑시킨다. 가장 많이 사용되며 기능도 많다.

주로 name, nullable 속성이 사용되며 나머지는 잘 사용되지 않는다고 한다. 그 외 속성들은 나중에 읽어보기. 아래는 "거의 사용하지 않음" 이라고 적히지 않은 속성들 정리.

```
nullable : null 값의 허용 여부를 설정한다. false로 설정하면 DDL로 not null 제약 조건을 추가해 준다.
unique : 한 컬럼에 유니크 제약 조건을 건다. 일반적으로는 한 컬럼에만 사용할 수 있는 듯함.
columnDefinition : 데이터베이스 컬럼 정보를 직접 줄 수 있다고 함. 뭔 소린지 모르겠으니 나중에 찾아보기.
length : 문자 길이 제약 조건을 건다. String 타입에만 사용한다.
precision, scale : 고정소수점?에서 전체 자릿수와 소수점 자릿수를 지정할 때 사용한다.
```

** @Column 어노테이션을 생략할 경우 변수형, 객체형에 따라 DDL이 알아서 변환된다.(변수형은 NULL을 못 넣으므로 not null 자동으로 들어가는 식) 이 때 변수형에 @Column을 사용하면 nullable = true가 기본으로 들어가므로 nullable=false를 따로 지정해주는 것이 안전하다.

@Enumerated는 enum 타입을 매핑할 때 사용한다. .ORDINAL, .STRING 등의 속성이 있으며 특징은 아래와 같다.

```
1. .ORDINAL : 지정한 enum  내 값의 순서들만 숫자로 저장한다. 데이터베이스에 저장되는 데이터 크기는 작지만, 저장된 enum의 순서를 변경할 수 없다. 기본 값이지만 주의해서 사용해야 한다.
2. .STRING : 지정한 enun 내 값을 문자열 형태 그대로 저장한다. 저장된 enum의 순서가 바뀌거나 추가되어도 안전하지만, 데이터베이스에 저장되는 데이터 크기가 상대적으로 크다. 이 쪽 사용을 권장한다고 한다.
```

@Temporal은 날짜 타입을 매핑할 때 사용한다. 속성으로 .DATE, .TIME, .TIMESTAMP가 있으며 데이터베이스의 각 타입(date, time, timestamp)과 매핑되며 반드시 지정해줘야 한다.

@Temporal을 생략할 경우 자바의 Date와 가장 유사한 timestamp로 자동 정의된다. MySQL은 datetime으로 변경된다고 한다.

@Lob은 데이터베이스 BLOB과 CLOB 타입과 매핑한다. 별도 속성은 없으며, 매핑시키는 필드 타입이 문자면 CLOB으로, 그 외에는 BLOB으로 매핑시킨다.

**BLOB과 CLOB이란? 대용량 데이터를 저장하는 데이터 타입으로, BLOB은 이미지, 동영상, 오디오, 문서 등의 파일을 저장하고 CLOB은 대용량의 텍스트 데이터(로그, 웹사이트 등)를 저장한다.

@Transient는 매핑을 아예 하지 않는다. 데이터베이스에 저장도 되지 않고 조회도 되지 않는다. 객체에 임시로 어떤 값을 보관하고 싶을 때 사용한다.

@Access는 엔티티 데이터에 접근하는 방식을 지정한다. 필드 접근과 프로퍼티 접근 방식이 있다.

```
필드 접근 : AccessType.FIELD 속성으로 지정한다. 필드에 직접 접근하며 private여도 접근할 수 있다.
프로퍼티 접근 : AccessType.PROPERTY로 지정한다. 접근자(Getter)를 사용한다.
```

@Access를 설정하지 않으면 @Id 어노테이션이 적용된 위치를 기준(필드인지? 메소드(혹은 필드 외)인지?)를 체크해 접근 방식이 설정된다.

# 정리 및 실전 예제 (153 ~ 161 페이지) : 정리는 별다른 내용 없어 패스. 실전 예제는 나중에 해보기.

===========================================================================5장 : 연관관계 매핑 기초

엔티티들은 대부분 다른 엔티티와 연관관계를 가진다. 하지만 자바는 객체 참조를 이용해 관계를 맺고 테이블은 외래 키를 통해 관계를 맺는다. 이 서로 다른 관계를 서로 매핑시키는 것은 아주 어렵다.

연관관계를 이해하기 위해 필요한 키워드들은 아래와 같다.

```
방향 : 단방향과 양방향이 있다. 두 단위가 있을 때 한 단위가 다른 한 단위만 참조하면 단방향, 서로 참조하는 것을 양방향이라고 한다.
다중성 : 다대일, 일대다, 일대일, 다대다가 있다. 두 단위가 각각 서로를 연관짓는 범위를 결정한다. (예시 - 회원과 팀의 관계는 다대일 관계. 팀과 회원은 일대다 관계 등)
연관관계의 주인 : 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다.
```

# 단방향 연관관계 (164 ~ 173 페이지) 진행 중

연관관계 중에선 다대일 단방향 관계를 가장 먼저 이해해야 한다.

```
회원과 팀이라는 두 단위가 있다.
회원은 하나의 팀에만 소속될 수 있다.
그렇다면 회원과 팀은 다대일 관계이다.
```

위 상황에서, 객체(자바)에서는 필드와 참조를 통해 팀 객체와 연관관계를 맺는다. (각 멤버 객체가 팀 객체를 보유하고 있음) 이를 객체 그래프 탐색이라고 한다.

자바에서의 위 관계는 단방향 관계이다. 회원은 자신의 팀 객체에 접근해 팀을 알 수 있지만 팀은 회원을 알 수 없다.

테이블의 경우 회원 테이블에서 외래 키를 통해 팀과 연관관계를 맺는다. 이 연관관계는 양방향 관계이다. 회원 테이블의 외래키(team_id 같은 것)를 통해 회원과 팀을 조인할 수 있고, 팀에서도 회원을 조인할 수 있다.

이렇게 객체 연관관계와 테이블 연관관계의 가장 큰 차이는 단방향/양방향의 차이이다. 자바는 참조로 인해 단방향이지만 테이블은 외래키로 인해 항상 양방향으로 진행된다.

** 참조(자바)에서 양방향으로 참조시키려면 단방향 연관관계를 2개 만드는 것이 되므로 유의해야 한다.

테이블에서의 연관관계는 외래 키를 통해서 이루어지며, 이 외래키를 통한 탐색을 조인이라고 한다.

위 서로 다른 방식으로 연관관계를 맺는 자바와 테이블을 JPA를 통해 매핑시킬 수 있다. 아래 방식을 따른다.

``` 다대일 관계인 회원과 팀을 JPA에서 매핑시키기 (자바에서임)
A. 각 연관관계에 알맞는(다대일 관계에서는 다인 쪽에) 객체에 적절한 어노테이션(예시 - 다대일이라면 @ManyToOne)을 사용한다. 어노테이션 속성은 따로 찾아보기.
B. 테이블의 외래 키에 해당하는 클래스 필드에 @JoinColumn 어노테이션 및 키 이름에 해당하는 속성(name = "테이블에서의 키 이름")을 적어 매핑시킨다.
```

# 연관관계 사용 (173 ~ 178 페이지)

JPA에서 엔티티를 저장할 때 연관되어 있는 모든 엔티티는 영속 상태여야 한다.

JPA는 참조 중인 엔티티의 식별자(@Column 어노테이션으로 매핑 시킨, 외래키에 해당하는 필드 값)를 외래 키로 사용해 등록 쿼리를 생성한다.

JPA가 생성한 쿼리를 확인해 보면, 참조 중인 클래스가 있는 객체를 외래키로 찾을 수 있는 행이 적절하게 삽입된 것을 확인할 수 있었다.

연관 관계인 엔티티를 조회하는 방법은 객체 그래프 탐색과 객체지향 쿼리, 2가지 중 하나를 사용하는 방법이 있다.

객체 그래프 탐색이란, 엔티티 매니저를 통해 관리 중인 엔티티를 객체로 받아온 다음, 해당 객체를 통해 연관된 엔티티를 조회하는 방법이다. .get엔티티명() 메소드가 등장했다.

객체지향 쿼리는 JPQL이 등장했다. 뭔지 자세히는 모르지만 쿼리와 비슷한 문법이면서도 관계를 가진 객체와 그 필드를 다루듯이 조인을 시킬 수 있는 것 같다.

연관관계를 수정할 경우, 엔티티 매니저에서는 .update() 메소드가 없기 때문에 엔티티를 불러와 .set엔티티명() 메소드 등을 통해 연관관계가 될 객체를 갈아끼우면 된다.

연관관계를 제거하려면 연관 객체가 있는 객체의 .set엔티티명(null) 을 통해 연관시키고 있는 객체를 비워주면 된다.

연관된 엔티티를 삭제하려면 외래 키 제약조건에 따라 기존의 연관관계를 먼저 제거한 후에 엔티티를 삭제해야 한다. 위의 .set엔티티명(null) 을 통해 연관관계인 객체를 다 비워주면 된다.

# 양방향 연관관계 (178 ~ 180 페이지)

이전까지의 회원-팀 연관관계는 다대일 단방향 매핑이었다. 회원에서 팀에만 접근하지 않고, 팀에서도 회원으로 접근할 수 있게 되면 양방향 연관관계가 된다.

```
MEMBER 객체는 id, Team(객체), username 필드를 가지고 있다. << Team 객체를 통해 Team과 연관
TEAM 객체는 id, name, members(List) 필드를 가지고 있다. << members 리스트를 통해 Member와 연관(팀과 멤버는 일대다 관계이므로 리스트로 관리해야 한다)
```

테이블에서의 양방향 연관관계는 본래 외래 키를 통해 가능했다. 그러므로 테이블 상에서 변화하는 내용은 없다. 외래 키와 조인을 활용하면 서로가 서로에게 접근할 수 있다.

JPA에서 양방향 관계를 매핑하려면 위 변동사항에 맞춰 아래와 같이 코드를 추가해줘야 한다.

```
A. members(LIST)가 추가되었으므로 필드로 private List<Member> members = new ArrayList<Member>(); 를 추가해 준다.
B. A로 추가한 필드에 @OneToMany(mappedBy = 반대쪽에서 이쪽에 매핑하기 위해 만든 필드명) 어노테이션과 속성을 입력해 준다. 위 예시에서 속성에 대한 값은 member에서 이쪽에 매핑시키기 위한 필드인 team이 될 것이다.
```

위처럼 양방향 매핑으로 추가 매핑된 부분도 객체 그래프 탐색을 통해, 즉 em.find()를 통해 조회할 수 있다.

# 연관관계의 주인 (181 ~ 184 페이지) 진행 중

위에서 적었듯, 사실 객체 간에는 양방향 연관관계가 성립하지 않는다. 단방향 연관관계 2개를 양방향인 것처럼 묶어줄 뿐이다.

테이블은 외래키 하나만 있으면 두 테이블을 양방향으로 연관시킬 수 있지만, 엔티티의 양방향은 참조를 두 개 걸어야 하는 것이 중요한 차이이다.

이 차이로 인해 JPA에서는 두 객체의 연관관계 중 하나를 테이블의 외래키처럼 정해서 관리해야 하는데, 이를 연관관계의 주인이라고 한다.

연관관계의 주인이 된 쪽만이 데이터베이스 쪽 연관관계와 매핑되고 외래 키를 관리할 수 있다. 주인이 아닌 쪽은 읽기만 할 수 있다.

이러한 주인관계를 지정해 주는 것이 위의 @OneToMany 어노테이션의 속성으로 지정했던 mappedBy 속성이다.

mappedBy 속성은 "주인이 아닌 쪽" 에서 사용한다는 점 주의하자. 주인은 mappedBy 속성을 사용하지 않는다.

주인이 아닌 쪽에서 mappedBy 속성을 사용하며, 속성의 값을 통해 연관관계의 주인을 지정한다.

Member에는 team 필드가, Team에는 members 필드가 있다. 이 중에서 어느 쪽을 주인으로 지정해야 할까?

연관관계의 주인을 정한다는 것은 외래 키 관리자를 선택한다는 것과 같다. 위 두 객체의 관계를 살펴보면, 외래키에 해당하는 외래 키이자 필드는 team_id이다.

테이블 상에서 TEAM_ID는 MEMBER 테이블에 있다. 이 경우 Member 엔티티는 자신 테이블과 매핑되어 있어 자신의 외래 키를 관리하면 되지만, Team 엔티티는 TEAM 테이블에 매핑되어 있어 물리적으로 떨어진 테이블의 외래 키를 관리해야 한다.

위 이유로 연관관계의 주인은 테이블에 외래 키가 있는 쪽 엔티티로 정해야 한다. 즉 위 상황에서는 Member 엔티티의 .team 필드가 외래 키를 가지고 있으므로 주인이 되어야 한다.

이 경우 mappedBy 속성은 Team.members 필드에 사용하며, 속성의 값은 주인이 되는 필드를 적어주면 된다. mappedBy="team" 가 될 것이다.

정리하면 양방향 연관관계의 경우 주인이 데이터베이스 연관관계에 직접 매핑되어 외래 키를 관리할 수 있다. 주인이 아닌 반대쪽은 읽기만 가능하며 외래 키를 변경할 수 없다.

** 데이터베이스 테이블에서 다대일, 일대다 관계에서는 항상 다 쪽이 외래키를 가지게 된다. 즉, @ManyToOne 어노테이션을 붙이는 쪽이 외래키를 가지기 때문에 항상 주인이 되며, 결국 @ManyToOne 어노테이션에는 mappedBy 속성이 없다.

# 양방향 연관관계 저장(185 ~ 186 페이지) 진행 중

양방향 연관관계에서는 주인이 외래 키를 관리한다. 즉 주인이 아닌 쪽은 값을 별도로 설정하지 않아도 데이터베이스 확인 시 외래 키 값이 입력된다.

위 상태에서 외래 키를 관리하려면 Member.team 필드에 접근해야 한다.

# 양방향 연관관계의 주의점(186 ~ 192 페이지)

양방향 연관관계를 설정하고 가장 자주 하는 실수는 주인이 아닌 쪽에만 값을 입력하는 것이라고 한다. 이 경우 외래 키가 정상적으로 저장되지 않으므로 의심해 보아야 한다.

주인이 아닌 쪽에서 데이터를 저장할 경우, 외래 키는 저장되지 않기 때문에 데이터로 외래 키 조회시 null이 입력된다.

하지만 의외로 객체 관점에서는 양쪽 방향에 모두 값을 입력해 주는 것이 가장 안전하다고 한다. 주인 쪽에서만 관계를 설정할 경우, JPA를 사용하지 않을 때 일부 정보 확인 시 오작동할 수 있기 때문이다.

결국 양방향 연관관계에서는 두 방향에서의 코드를 모두 작성해야 한다. 그렇기 떄문에 메소드를 작성할 때부터 두 방향의 관계를 모두 설정하도록 리팩토링하는 것이 좋다. 이런 메소드를 연관관계 편의 메소드라고 한다.

하지만 연관관계 편의 메소드 상에서 관계를 변경하려면 기존 관계를 제거하고 변경해야 하는 등, 많은 고민과 수고가 든다.

# 정리 (193 ~ 195 페이지)

단방향 매핑과 비교하여 양방향 매핑은 복잡하다. 연관관계의 주인도 정해야 하고, 두 개의 단방향을 양방향처럼 만들기 위해 로직에도 신경을 써야 한다.

하지만 결국 양방향은 단방향과 비교했을 때 주인이 아닌 쪽의 연관관계를 하나 추가하는 것 뿐이며, 반대방향으로 객체 그래프를 탐색할 수 있게 되는 것 뿐이다.

주인이 아닌 쪽은 mappedBy 속성을 통해 주인이 되는 쪽을 지정해야 한다. 또한 객체 그래프 탐색만 가능하며, 외래키 변경 없이 읽기만 가능하다.

정리하면 아래와 같다.

```
A. 단방향 매핑만으로도 테이블과 객체의 연관관계 매핑은 완료된다.
B. 단방향을 양방향으로 만들면 주인이 아닌 쪽에서도 객체 그래프 탐색을 사용할 수 있게 된다.
C. 양방향 연관관계를 매핑시키려면 객체 측에서 양쪽 방향을 모두 관리(연결로 이해하겠음) 해야 한다.
```

양방향 매핑은 복잡하므로 단방향 매핑을 사용하고, 필요할 때 양방향 코드를 추가해도 된다.

** 연관관계의 주인에 대한 경우, 단방향은 항상 외래 키가 있는 곳을 중심으로 매핑시키면 된다. 양방향의 경우, 외래키가 있는 쪽에만 집중해서 결정하는 것이 좋다. 비즈니스 중요도로 접근하지 마라.

** 양방향 매핑 시에는 무한 루프에 빠지지 않게 조심해야 한다. 무슨 소리인지 모르겠으므로 나중에 찾아보기.

# 실전 예제 (196 ~ 201 페이지) : 나중에 복습할 때 풀어보기

================================================================================6장 : 다양한 연관관계 매핑

다양한 연관관계에 대해 정리하기 전에 앞 장에 대한 복습. 엔티티의 연관관계를 매핑할 때에는 아래 3가지를 고려해야 한다.

```
A. 다중성 : 다대일, 일대다, 일대일, 다대다인지를 가리킨다.
B. 단방향, 양방향 : 두 객체 중 한 쪽이 한 쪽만 참조하는 상태가 단방향, 양쪽이 서로 참조하는 상태가 양방향이다.
C. 연관관계의 주인 : JPA에서는 두 객체가 연관관계를 맺을 경우 하나가 외래 키를 관리해야 하고, 이를 주인이라 한다. 보통 외래 키를 가진 테이블과 매핑한 엔티티가 연관관계의 주인이 된다.
```

위 내용을 기억한 상태로 다중성, 단/양방향을 고려한 모든 경우의 연관관계를 알아보자. 다중성의 경우 왼쪽에 온 쪽이 연관관계의 주인임을 약속하고 간다.

# 다대일 관계 (206 ~ 208 페이지)

데이터베이스 테이블에서 일대다, 혹은 다대일 관계일 때 외래 키는 항상 다인 쪽에 있다. JPA 어노테이션을 통해 다대일 단방향 관계를 나타내는 방법을 정리하면 아래와 같다.

``` 회원(Member)과 팀(Team) 다대일 단방향 관계에서의 어노테이션 편성
A. 회원 엔티티에서, 일인 쪽으로 참조하는 필드(여기서는 Team 필드)에 @ManyToOne 어노테이션을 붙인다.
B. 회원 엔티티에서, 자신 테이블(MEMBER 테이블)의 외래 키를 관리할 필드(여기서는 Team 필드)에 @JoinColumn 어노테이션을 붙이고, name 속성에 외래 키 이름을 붙여 매핑시켜준다.
C. 팀 엔티티에서는 @Column 어노테이션을 통해 외래 키에 해당하는 필드를 데이터베이스 외래 키 이름과 매핑시켜 준다.
```

위 상황에서 단방향이 아닌 양방향으로 변환되면 아래 코드가 추가된다.

``` 회원(Member)과 팀(Team) 다대일 양방향 관계에서의 어노테이션 편성
A. 회원 엔티티에서는 큰 변화 없음.
B. 팀 엔티티에서, 회원을 참조할 회원 리스트를 만들었으므로 해당 필드에 @OneToMany 어노테이션을 붙여준다.
C. 양방향 관계가 되었으므로, @OneToMany 어노테이션에 양방향 주인관계를 명시할 mappedBy 속성을 추가한다. 속성의 값은 주인이 되는 필드의 이름이다.(여기서는 Team)
```

양방향은 외래 키가 있는(외래 키를 가진 테이블과 매핑되어있는) 엔티티가 연관관계의 주인이 된다.

또한, 양방향 연관관계는 항상 서로를 참조해야 한다. 이를 위해 연관관계 편의 메소드를 작성하는 편이고, 이 과정에서 무한 루프에 빠지지 않게 조심해야 한다.

# 일대다 (209 ~ 214 페이지)

일대다 관계는 다대일 관계의 반대 방향이다. 일대다 상태에서는 일인 쪽이 엔티티를 하나 이상 참조할 수 있기 때문에 자바의 컬렉션을 사용하게 된다.

일대다 단방향 관계는 조금 특이한데, 일인 쪽에서 리스트를 통해 다인 쪽(외래 키를 가진 쪽)의 테이블 속 외래키를 참조하는 그림이 나오게 된다.

엔티티 내에서의 어노테이션 구성은 아래와 같아진다.

``` 팀과 회원의 일대다 관계에서의 어노테이션 구성
A. 팀 엔티티(Team)에서 멤버 객체를 보관하는 리스트 필드에 일대다를 명시하는 @OneToMany 어노테이션을 적는다.
B. 리스트 필드에 다인 쪽에서 관리하는 외래 키와 매핑시킬 어노테이션 @JoinColumn 어노테이션과 name 속성, 외래키로 쓰는 값 "TEAM_ID" 을 적는다.
```

일대다 단방향 매핑의 단점은 외래 키가 반대쪽 테이블에 있다는 것이다. 이렇게 되면 연관관계 처리를 위해 SQL이 복잡해진다. 추가된 SQL 해석은 아래와 같다.

```
A. 외래 키를 가진 Member 엔티티는 Team 엔티티를 모른다. 하지만 연관관계의 정보는 Team의 members 필드에서 관리하고 있다.
B. 그러므로 Member 엔티티가 저장되어도 MEMBER 테이블의 TEAM_ID 외래키에는 아무 값도 저장되지 않는다.
C. 대신 Team 엔티티가 저장될 때, Team 엔티티 속 members의 참조 내용을 확인하여 비어있던 위의 외래키를 UPDATE 시켜준다.
```

위 이유로 일대다 단방향 매핑을 사용하는 상황이라면 그냥 다대일 양방향 매핑을 사용하는 게 낫다. 엔티티만 약간 수정하면 구조도 비슷하다고 한다.

일대다 양방향(일인 쪽이 연관관계의 주인이 되는 상태의 양방향)은 존재하지 않는다고 한다. 왜냐하면 주인은 다인 쪽이 주인이 되어야 하기 떄문이다. 대신 다대일 양방향 매핑을 사용한다.

# 일대일 (214 ~ 페이지) 진행 중

일대일 관계는 서로가 하나씩하고만 관계를 가진다. 회원과 사물함이라면, 회원도 사물함도 서로 하나씩만 가질 수 있다는 의미이다.

일대일 관계는 그 반대도 일대일 관계이며, 일대다/다대일과 다르게 두 테이블 중 어느 쪽에도 외래 키가 있을 수 있다. 즉, 주 테이블이나 대상 테이블 중 누가 외래 키를 가질지 선택해야 한다.

주 테이블이 외래 키를 가질 경우, 객체지향적 개발 스타일에 가까워진다고 한다. 반면, 대상 테이블에 외래 키를 둘 경우 일대다로 변경할 때에도 테이블 구조를 유지할 수 있다고 한다.

주 테이블에 외래 키를 가지면 JPA 사용 시 더 편리하게 매핑할 수 있다.
