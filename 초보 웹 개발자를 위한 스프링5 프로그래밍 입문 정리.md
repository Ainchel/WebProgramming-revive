공부 방법을 변경하게 되었다.
책 속 코드나 용어를 전부 하나하나 분석하고 정리하는 방향에서, 책에 등장하는 용어나 기법에 대해 간략히 정리하고 기억해둠으로써 책을 빠르게 소화하는 방향으로 바꾸었다.
이는 추후 프로젝트를 시작하게 되었을 때 기억하고 있는 다양한 기법이나 패턴을 떠올릴 수 있게 되는 것에 더욱 힘을 주고 상세한 코드나 기술에 대한 건 프로젝트 중에 직접 체험해가며 실력을 키우는 것이 더욱 효율적이라 판단되었기 때문이다.

# 컴포넌트 스캔(130페이지 ~ 140페이지)

스프링에서 특정 클래스에 이름을 붙여 빈 객체로 등록해주는 기능을 컴포넌트라고 한다.

@Component 어노테이션을 사용하면 특정한 이름, 혹은 본래 클래스 이름(첫 글자만 소문자화시킨)의 빈 객체를 생성할 수 있다.
그리고 @ComponentScan 어노테이션을 사용해, 위 @Component로 등록한 클래스 객체를 Bean 객체로 등록시킨다.

이 과정을 거치면 @Component 어노테이션을 통해 빈 이름을 지정하게 되었으므로 기존의 getBean 메소드에서 이름을 지정할 필요가 없어진다.
그 외 특정 속성을 사용하여 빈 객체 자동 생성 대상을 제외하는 등의 기능이 가능하다.

@Component 어노테이션 외에도 @Controller, @Service, @Repository, @Aspect, @Configuration 등 어노테이션도 역할은 다르지만 같은 빈 검색&등록 기능을 수행한다.
빈 객체 자동 등록 기능을 사용할 때에는 빈 이름 관련, 수동 등록과 관련하여 충돌이 발생할 수 있으니 주의해야 한다.

# 빈 객체의 라이프사이클과 범위(141페이지 ~ 151페이지)

어노테이션을 통해 생성하는 빈 객체들은 개발자의 코드 밖에 있는 저장소인 스프링 컨테이너에 저장된다.
스프링 컨테이너는 필요시 초기화되고 사용을 완료하면 종료되는 사이클을 가지고 있다.
AnnotationConfigApplicationContext 객체를 생성하는 순간이 컨테이너가 초기화되는 순간이다. 이 때 빈 객체가 생성되고, 각 빈끼리의 의존 주입이 실행된다.
컨테이너가 초기화되어 있는 동안, AnnotationConfigApplicationContext 객체의 getBean() 메소드 등을 사용하여 빈 객체에 접근한다.
컨테이너 사용을 마친 후 AnnotationConfigApplicationContext 객체의 close() 메소드를 사용하여 컨테이너를 종료한다. 이 때 컨테이너 내부의 빈 객체가 소멸된다.
빈 객체를 초기화하고 소멸시키는 기능을 담당하는 각 인터페이스가 있는데, 이를 사용할 빈 객체에서 구현한 후 초기화/소멸 시 호출되는 메소드를 사용하면 초기화/소멸 시에 작동시킬 기능을 작성할 수 있다.
직접 생성한 클래스가 아니라 위 인터페이스를 구현할 수 없는 상황이라 해도, @Bean 어노테이션의 initMethod, destroyMethod 속성을 사용하면 초기화/소멸 시 실행시킬 메소드를 작성/지정할 수 있다.
빈 객체는 기본적으로 싱글톤(singleton) 범위로 하나의 객체만 생성되어 공유된다. 같은 이름의 다른 빈 객체를 생성할 수도 있지만 사용 빈도는 낮다.

# AOP 패턴에 대하여 (152 ~ 177페이지)

특정 기능이나 클래스를 여러가지 개발하다 보면 공통적으로 사용되는 코드가 생기기 마련이다.
예시 1) DBMS 사용 시, 자바 코드상으로 DB로 데이터를 전송하기 위해 자바와 DB를 중개해주는 객체를 생성하고 close 하는 과정
예시 2) 특정 기능들에 해당 기능이 1회 완료될 때까지 걸리는 시간의 로그를 남기는 과정

이러한 코드들을 매번 작성하는 것보다 별도로 나누어서 관리할 수 있게 된다면 해당 코드들을 반복해서 작성할 필요가 없을 것이다.
또한 반복되는 코드를 부품화하여 사용할 수 있기 때문에 핵심 기능의 개발에만 집중할 수 있을 것이다.

이렇게 여러 클래스를 개발할 때 '공통 기능' 과 '핵심 로직' 을 별도로 분리해서 개발/관리하는 패턴을 AOP(Aspect-Oriented Programming / 관점 지향 프로그래밍)라고 한다.
반복적으로 사용하게 될 공통 기능을 구상하게 되거나, 기존의 공통 코드를 간소화하여 코드를 경량화시키는 데 큰 도움이 될 것이다. 기억해 두자.

위의 AOP 패턴을 구현할 때 필요한 것이 프록시 객체이다. 공통 기능과 핵심 로직을 구분했을 때, 공통 기능을 담당하는 코드만 가지고 핵심 로직은 메소드는 다른 객체들 가져와 실행하는 객체가 프록시 객체이다.
프록시 객체의 핵심은 공통 기능만 구현하는 것이다. 핵심 로직은 외부 객체를 사용한다.

AOP 패턴을 사용할 때 사용하는 주요 용어는 아래와 같다.
1. Advice : 핵심 로직 외에 적용할 공통 기능을 가리킨다.
2. Joinpoint : Advice, 즉 핵심 로직을 적용할 지점을 정의한다. 가장 대표적인 경우는 메서드 호출이다.
3. Pointcut : Joinpoint의 보다 일반적인 범주를 지정한다.
4. Weaving : 공통 기능인 Advice을 적용 시점인 Pointcut에 실제 적용하는 작업이다.
5. Aspect : 위의 Advice부터 Point까지 작성한, 목적과 작동이 확정된 공통 기능의 단위이다.

스프링에서 널리 사용되는 공통 기능(Advice)는 메서드 실행 전/후, 예외 발생 시 작동할 기능(Around Advice)이다.
스프링에서는 어노테이션을 통해 AOP 패턴을 담당하는 위 기능들을 지정한다. @Aspect, @Around, @Pointcut 등의 어노테이션을 사용한다. 그 외의 AOP 관련 어노테이션들은 추후 공부하는 것으로.

# DB 연동에 대하여(178페이지 ~ 231P)

## JdbcTemplate 클래스
JDBC를 사용할 경우 실질적인 프로젝트의 기능과 관계가 없지만 구조적으로 반복되는 코드가 생기게 된다. 스프링에서 제공하는 JdbcTemplate 클래스를 활용하면 이 반복을 줄일 수 있고, 편하게 쿼리를 실행시킬 수 있다.
 
 ## 트랜잭션
 스프링을 사용하면 트랜잭션 관리 또한 쉬워진다. 트랜잭션이란 "시작부터 끝까지 온전히 성공해야 하는 논리적으로 연결된 하나의 작동" 을 전제로 하는 작업이다.
 트랜잭션의 결과는 성공(시작부터 끝까지 온전히 작동함) 혹은 그렇지 못한 상태일 것이다.
 이 경우 트랜잭션이 성공했다면 결과를 확정짓겠지만, 실패했다면(온전히 작동하지 않았다면) 트랜잭션 시작 이전으로 모든 상태를 되돌려야 한다.
 결과의 확정을 커밋(Commit), 상태를 되돌리는 것을 롤백(Rollback)이라고 한다.
 스프링에서 @Transaction 어노테이션을 사용하면 트랜잭션 범위를 쉽게 지정하여 실행/관리할 수 있다. 어노테이션 사용법은 나중에 조사한다.
 @Transaction 어노테이션은 트랜잭션을 실행해도 시작과 결과(커밋or롤백) 여부를 확인할 수 없다. 이를 확인하려면 스프링을 통해 로그 메시지를 봐야 한다.
 @Transaction 어노테이션은 상기한 AOP 패턴을 사용하며, 프록시 객체를 통해 기능을 구현해 두었다고 한다.
 @Transaction 어노테이션을 적용한 객체의 메서드에서 Runtime Exception이 발생할 경우에는 자동으로 트랜잭션이 롤백된다.
 
 ## 커넥션 풀
 자바에서 DB로 한 번 연결하는 과정은 컴퓨터 입장에서 꽤 큰 시간을 소모한다.
 그래서 매번 DB로 데이터를 전송하는 시점에 DB와 연결을 하게 된다면 비효율적이게 된다.
 이를 위해 일정 수의 연결을 미리 만들어 둔 뒤 생성/소멸시키지 않고 활성/유휴만 시키는 패턴을 커넥션 풀이라고 한다.
 Tomcat JDBC 모듈의 DataSource 클래스가 이러한 커넥션 풀 기능을 지원하고 있다.
 
 # 스프링 MVC에 대하여 (232페이지 ~ 248페이지)
 
 스프링은 웹 MVC 프레임워크 또한 지원한다.
 스프링 MVC를 실행하려면 자바 파일을 통한 구성 요소 설정이 필요하다. 본래는 수십 줄의 코드를 작성해야 하지만, @EnableWebMvc 어노테이션을 사용하면 내부적으로 설정을 마칠 수 있다고 한다.
 또한 web.xml 파일에 DispatcherServlet을 설정해야 한다.
 그 외 웹 어플리케이션 설정(톰캣 등) 또한 나중에 조사한다.
 
 책에 등장하는 각종 어노테이션은 명칭만 정리하며, 정확한 기능 및 사용법은 추후 조사한다.
 1. @GetMapping 어노테이션
 2. @RequestParam 어노테이션
 
 MVC 중 컨트롤러 : 컨트롤러는 사용자로부터 특정한 입력이나 명령을 해석 및 분류하여, 나머지 Model과 View로 연결시키는 기능을 수행한다.
 MVC 중 뷰 : 뷰는 사용자가 실제 접하게 되는 화면을 가리킨다. 초기 화면부터 시작해서 사용자가 요청한 내용을 처리한 후 보여야 할 결과나 데이터를 화면에 출력시킨다.
 MVC 중 모델 : 모델은 사용자가 요청한 명령이나 데이터 등을 실제로 처리하는 부분이다. 사용자에게 드러나지는 않지만 실제 필요한 데이터의 처리나 DB 연동 등의 작업은 모델에서 실행된다.
 
 스프링 MVC 프레임워크를 사용하면 모델에서 처리한 데이터를 뷰(실제 화면 단 - 즉 웹페이지 - java가 아닌 jsp 등 페이지 파일)에서도 접근할 수 있다.
 
 # 스프링 MVC 프레임워크의 동작 방식에 대하여(249페이지 ~ 262 페이지)

스프링 MVC 구조에서 DispatcherServlet은 사용자로부터 요청을 받아 컨트롤러 객체(@Controller 어노테이션을 사용한 클래스 객체)를 검색하고, 내부의 다른 빈 객체로 전달하는 역할을 담당한다.
스프링 MVC에서 웹 요청을 실제로 처리하는 객체를 핸들러(Handler) 객체라고 표현한다.
스프링 MVC에서 DispatcherServlet는 Model에서 처리한 데이터를 View로 전달하는 것 또한 담당한다.
그 외에도 DispatcherServlet에서 제어한 흐름에 따라 핸들러 객체를 찾아주고 핸들러 객체가 사용자의 요청을 처리한다. 이후 처리한 데이터를 뷰에 전달하는 방식으로 작동한다.

# MVC 1 : 요청 매핑, 커맨드 객체, 리다이렉트, 폼 태그, 모델(263페이지 ~ 292페이지) 진행중

웹 어플리케이션을 개발한다는 것은 아래 코드를 작성한다는 것이다.

A. 특정 요청 URL을 처리할 코드
B. 처리 결과를 HTML과 같은 형식으로 응답하는 코드

이 챕터에서 등장하는 어노테이션들은 이름만 기록해두고 추후 조사 및 활용한다.
 @Controller 어노테이션 : 
 @RequestMapping 어노테이션 : 
 @GetMapping 어노테이션 : 요청 경로에 처리할 메서드를 지정한다.

get 방식 : 서버에 올라가있는 데이터를 받아올 때 사용한다.
post 방식 : 서버에 올라가있는 데이터를 수정할 때 사용한다.
리다이렉트 : 잘못된 전송 방식으로 요청이 들어왔을 때, 알맞은 경로로 재요청(리다이렉트) 시킨다.
스프링 MVC에서는 뷰로 전달된 커맨드 객체(form 형식으로 자바->페이지로 전송하는 데이터)를 jsp 코드를 통해 접근할 수 있다.

스프링 MVC를 이용한 웹 개발 시 아래와 같은 에러를 자주 만날 수 있으므로 주의해야 한다.

A. 404 에러 : 요청 경로 및, 경로를 처리한 빈 객체가 존재하지 않는 경우 발생하는 에러이다. 아래 조건을 확인해 보자.
A-1. 요청 경로가 제대로 되었는지
A-2. 컨트롤러에 설정한 경로가 제대로 되었는지
A-3. 컨트롤러 클래스를 빈 객체로 등록했는지
A-4. 컨트롤러 클래스에 @Controller 어노테이션을 적용했는지. Aspect : 위의 Advice부터 Point까지 작성한, 목적과 작동이 확정된 공통 기능의 단위이다.

스프링에서 널리 사용되는 공통 기능(Advice)는 메서드 실행 전/후, 예외 발생 시 작동할 기능(Around Advice)이다.
스프링에서는 어노테이션을 통해 AOP 패턴을 담당하는 위 기능들을 지정한다. @Aspect, @Around, @Pointcut 등의 어노테이션을 사용한다. 그 외의 AOP 관련 어노테이션들은 추후 공부하는 것으로.

# DB 연동에 대하여(178페이지 ~ 231P)

## JdbcTemplate 클래스
JDBC를 사용할 경우 실질적인 프로젝트의 기능과 관계가 없지만 구조적으로 반복되는 코드가 생기게 된다. 스프링에서 제공하는 JdbcTemplate 클래스를 활용하면 이 반복을 줄일 수 있고, 편하게 쿼리를 실행시킬 수 있다.
 
 ## 트랜잭션
 스프링을 사용하면 트랜잭션 관리 또한 쉬워진다. 트랜잭션이란 "시작부터 끝까지 온전히 성공해야 하는 논리적으로 연결된 하나의 작동" 을 전제로 하는 작업이다.
 트랜잭션의 결과는 성공(시작부터 끝까지 온전히 작동함) 혹은 그렇지 못한 상태일 것이다.
 이 경우 트랜잭션이 성공했다면 결과를 확정짓겠지만, 실패했다면(온전히 작동하지 않았다면) 트랜잭션 시작 이전으로 모든 상태를 되돌려야 한다.
 결과의 확정을 커밋(Commit), 상태를 되돌리는 것을 롤백(Rollback)이라고 한다.
 스프링에서 @Transaction 어노테이션을 사용하면 트랜잭션 범위를 쉽게 지정하여 실행/관리할 수 있다. 어노테이션 사용법은 나중에 조사한다.
 @Transaction 어노테이션은 트랜잭션을 실행해도 시작과 결과(커밋or롤백) 여부를 확인할 수 없다. 이를 확인하려면 스프링을 통해 로그 메시지를 봐야 한다.
 @Transaction 어노테이션은 상기한 AOP 패턴을 사용하며, 프록시 객체를 통해 기능을 구현해 두었다고 한다.
 @Transaction 어노테이션을 적용한 객체의 메서드에서 Runtime Exception이 발생할 경우에는 자동으로 트랜잭션이 롤백된다.
 
 ## 커넥션 풀
 자바에서 DB로 한 번 연결하는 과정은 컴퓨터 입장에서 꽤 큰 시간을 소모한다.
 그래서 매번 DB로 데이터를 전송하는 시점에 DB와 연결을 하게 된다면 비효율적이게 된다.
 이를 위해 일정 수의 연결을 미리 만들어 둔 뒤 생성/소멸시키지 않고 활성/유휴만 시키는 패턴을 커넥션 풀이라고 한다.
 Tomcat JDBC 모듈의 DataSource 클래스가 이러한 커넥션 풀 기능을 지원하고 있다.
 
 # 스프링 MVC에 대하여 (232페이지 ~ 248페이지)
 
 스프링은 웹 MVC 프레임워크 또한 지원한다.
 스프링 MVC를 실행하려면 자바 파일을 통한 구성 요소 설정이 필요하다. 본래는 수십 줄의 코드를 작성해야 하지만, @EnableWebMvc 어노테이션을 사용하면 내부적으로 설정을 마칠 수 있다고 한다.
 또한 web.xml 파일에 DispatcherServlet을 설정해야 한다.
 그 외 웹 어플리케이션 설정(톰캣 등) 또한 나중에 조사한다.
 
 책에 등장하는 각종 어노테이션은 명칭만 정리하며, 정확한 기능 및 사용법은 추후 조사한다.
 1. @GetMapping 어노테이션
 2. @RequestParam 어노테이션
 
 MVC 중 컨트롤러 : 컨트롤러는 사용자로부터 특정한 입력이나 명령을 해석 및 분류하여, 나머지 Model과 View로 연결시키는 기능을 수행한다.
 MVC 중 뷰 : 뷰는 사용자가 실제 접하게 되는 화면을 가리킨다. 초기 화면부터 시작해서 사용자가 요청한 내용을 처리한 후 보여야 할 결과나 데이터를 화면에 출력시킨다.
 MVC 중 모델 : 모델은 사용자가 요청한 명령이나 데이터 등을 실제로 처리하는 부분이다. 사용자에게 드러나지는 않지만 실제 필요한 데이터의 처리나 DB 연동 등의 작업은 모델에서 실행된다.
 
 스프링 MVC 프레임워크를 사용하면 모델에서 처리한 데이터를 뷰(실제 화면 단 - 즉 웹페이지 - java가 아닌 jsp 등 페이지 파일)에서도 접근할 수 있다.
 
 # 스프링 MVC 프레임워크의 동작 방식에 대하여(249페이지 ~ 262 페이지)

스프링 MVC 구조에서 DispatcherServlet은 사용자로부터 요청을 받아 컨트롤러 객체(@Controller 어노테이션을 사용한 클래스 객체)를 검색하고, 내부의 다른 빈 객체로 전달하는 역할을 담당한다.
스프링 MVC에서 웹 요청을 실제로 처리하는 객체를 핸들러(Handler) 객체라고 표현한다.
스프링 MVC에서 DispatcherServlet는 Model에서 처리한 데이터를 View로 전달하는 것 또한 담당한다.
그 외에도 DispatcherServlet에서 제어한 흐름에 따라 핸들러 객체를 찾아주고 핸들러 객체가 사용자의 요청을 처리한다. 이후 처리한 데이터를 뷰에 전달하는 방식으로 작동한다.

# MVC 1 : 요청 매핑, 커맨드 객체, 리다이렉트, 폼 태그, 모델(263페이지 ~ 292페이지) 진행중

웹 어플리케이션을 개발한다는 것은 아래 코드를 작성한다는 것이다.

A. 특정 요청 URL을 처리할 코드
B. 처리 결과를 HTML과 같은 형식으로 응답하는 코드

이 챕터에서 등장하는 어노테이션들은 이름만 기록해두고 추후 조사 및 활용한다.
 @Controller 어노테이션 : 
 @RequestMapping 어노테이션 : 
 @GetMapping 어노테이션 : 요청 경로에 처리할 메서드를 지정한다.

get 방식 : 서버에 올라가있는 데이터를 받아올 때 사용한다.
post 방식 : 서버에 올라가있는 데이터를 수정할 때 사용한다.
리다이렉트 : 잘못된 전송 방식으로 요청이 들어왔을 때, 알맞은 경로로 재요청(리다이렉트) 시킨다.
스프링 MVC에서는 뷰로 전달된 커맨드 객체(form 형식으로 자바->페이지로 전송하는 데이터)를 jsp 코드를 통해 접근할 수 있다.

스프링 MVC를 이용한 웹 개발 시 아래와 같은 에러를 자주 만날 수 있으므로 주의해야 한다.

A. 404 에러 : 요청 경로 및, 경로를 처리한 빈 객체가 존재하지 않는 경우 발생하는 에러이다. 아래 조건을 확인해 보자.
A-1. 요청 경로가 제대로 되었는지
A-2. 컨트롤러에 설정한 경로가 제대로 되었는지
A-3. 컨트롤러 클래스를 빈 객체로 등록했는지
A-4. 컨트롤러 클래스에 @Controller 어노테이션을 적용했는지
A-5. 요청 경로로 이어지는 JSP 파일이 제대로 존재하는지

B. 405 에러 : 지원하지 않는 전송(GET or POST) 방식을 사용했을 경우. 올바른 방식으로 요청했는지 확인해야 한다.

C. 400 에러 : @RequestParam 어노테이션 관련 에러. 아래와 같은 경우가 있다.
C-1. @RequestParam 처리 시 필요한 파라미터가 존재하지 않을 경우. 이 경우는 약관 동의 등의 기능에서 활용할 수도 있는 기능이다.
C-2. 요청한 파라미터의 값을 @RequestParam이 적용된 파라미터 타입으로 변환할 수 없는 경우. 

=============================================================================405 페이지까지 기술 및 용어 이야기만 등장하므로 나중에 기술적 지식 필요할 때 읽는다. 405페이지로 이동======================================================================

# 간단한 웹 어플리케이션의 구조(405페이지 ~ 414페이지)

간단한 웹 어플리케이션의 전형적인 구조는 아래와 같다.
A. 프론트 서블릿 : 웹 브라우저의 요청을 받는 창구 역할을 한다. 요청을 받은 후 알맞은 컨트롤러에 전달한다. 스프링 MVC에서는 DispatcherServlet이 이 역할을 담당한다.
B. 컨트롤러 + 뷰 : 컨트롤러는 웹 브라우저의 요청을 처리한다. 클라이언트(브라우저)에서 요청한 기능을 실행하고, 응답 결과를 생성하는 데 필요한 모델을 생성하고, 결과를 보낼 뷰를 선택한다. 즉, 컨트롤러가 직접 로직을 수행하지는 않는다.
C. 서비스 : 필요한 기능의 로직을 구현한다.
D. DAO : 서비스의 로직 중에서 DB와의 연동이 필요할 경우 사용한다. Date Access Object의 줄임말이며 웹 어플리케이션과 DB 간 데이터를 이동시키는 역할을 맡는다. 다만 DB의 데이터를 단순 조회하는 경우 컨트롤러 단에서 구현하기도 한다.

서비스는 핵심이 되는 로직이다. 만일 DB와 연동하는 서비스를 사용할 경우 여러 단계를 거쳐 진행하게 된다. 즉 트랜잭션 단위로 진행되는데, 트랜잭션이 중간에서 실패한다면 롤백을 해야 하고 성공하면 커밋을 진행해야 한다.

비슷한 데이터를 활용하는 기능들이라면 하나의 서비스 클래스에 모아서 구현하는 것도 한 방법이다. 예를 들면 회원가입, 비밀번호 변경 기능은 모두 회원 관련 데이터를 활용한 기능이므로 하나에 모을 수 있다.

서비스 클래스의 메서드는 핵심 로직을 실행하는 데 필요한 값들을 패러미터로 전달받는다. 이러한 값들을 한 데 모아 별도의 타입(클래스)를 만든다면 사용하기 편할 것이다.

서비스 메서드는 기능을 실행한 후 실행 결과를 알려줘야 개발자가 확인할 수 있다. 결과는 크게 두 가지 방식이 있다.
A. 리턴 값을 이용한 정상 결과 받기 : 비정상 결과가 없었을 경우 메서드 마지막에 결과를 리턴시킴
B. 익셉션을 이용한 비정상 결과 받기 : 기능 작동 도중 비정상 결과가 발생할 지점에 익셉션을 발생시킴

서비스 메서드에서 어떤 로직도 수행하지 않고 DAO의 메서드만 호출하고 끝나는 경우도 있다. 이런 경우에도 MVC에서의 서비스가 계층 구조를 유지한다고 볼 수도 있다고 한다.

웹 어플리케이션에서의 패키지 구조 또한 알아보자. 패키지 구성에 정답은 없지만, 핵심은 팀 구성원이 동일한 규칙에 따라 일관된 패키지 구성을 가져야 한다는 것이다.
웹 어플리케이션의 구조가 복잡해질 경우 MVC 설계만으로는 완벽히 역할을 분리해낼 수 없을 수도 있다. 이럴 경우에는 '도메인' 주도 설계를 적용해 보는 것 또한 고려할 수 있을 것이다.

# JSON 응답과 요청 처리 (415페이지 ~ 440페이지)

API를 호출할 경우, 요청에 대한 응답으로 XML, JSON 등을 사용한다. 스프링 MVC에서도 JSON 응답과 요청을 처리할 수 있다.
JSON이란 JavaScript Object Notation의 줄임말로, 데이터를 교환하는 데 사용하는 간단한 형식의 문자열이다. JSON의 규칙은 아래와 같다.
먼저 중괄호 {}로 객체를 표현한다. 각 객체는 "이름" : "값" 쌍을 갖는다. 값에는 문자열, 숫자, 불리언, null의 단일 값 / 배열 / 다른 객체가 들어갈 수 있다.
숫자의 경우 10진수 표기법(익히 아는 수 표시)과 지수 표기법(예시 : 1.07e2)을 사용할 수 있다. 불리언 값은 true나 false가 들어간다.
값으로 배열을 집어넣을 경우 대괄호를 사용한다. 대괄호 안에 각 값을 콤마로 구분하여 넣는다. (예시 : "list": ["남동순", 류예도])

자바 객체와 JSON 형식 문자열 간 변환을 처리하려면 스프링 MVC의 Jackson 라이브러리를 사용할 수 있다. 사용하려면 pom.xml 파일에 Jackson 관련 의존을 추가해야 한다.

사용하면 JSON의 객체를 클래스에 대응시키고, 내부의 값을 필드로 대응시켜 상호 교환시킨다.
스프링 MVC에서 JSON 형식으로 데이터를 변환시켜 응답하려면 @Controller 어노테이션 대신 @RestController 어노테이션을 사용한다.

응답 결과의 데이터 중, 비밀번호 같은 민감한 데이터는 제외시켜야 한다. 이럴 경우 클래스의 해당 필드 상단에 @JsonIgnore를 적으면 응답 결과에서 제외시킬 수 있다.

날짜 형식의 값은 자바에서 LocalDateTime 타입을 사용하지만, JSON 형식에서는 이 값을 연월일시분초를 각각 값으로 쪼갠 배열로 받아온다. 이 경우 LocalDateTime 같은 문자열로 변환시키기 위해 @JsonFormat 어노테이션을 사용하여 변환시킨다.
사용 방법은 LocalDateTime 필드 상단에 @JsonFormat 어노테이션을 사용한다. 성공할 경우 JSON 데이터에 위와 같은 배열이 아닌 LocalDateTime과 비슷한 형태의 문자열이 들어가게 된다. 기본 형태는 ISO-8601 형태라고 한다.
그 외 형식으로 출력하고 싶다면 @JsonFormat 어노테이션의 pattern 속성을 사용할 수 있다. 예시 : @JsonFormat(pattern = "yyyyMMddHHmmss")
하지만 pattern 속성에 적용할 수 있는 다른 형식도 정해진 모양새를 따라야 한다. 이는 java.time.format.DateTimeFormatter 클래스나 java.text.SimpleDateFormat 클래스의 정해진 패턴을 참고해야 한다.

날짜 형식을 위와 같이 변경할 수 있지만 매번 @JsonFormat 어노테이션을 붙여야 한다면 상당히 귀찮을 수 있다. 이 경우 Jackson이 JSON으로 변환시키는 규칙 자체를 바꿀 수 있다.
자세한 방식은 MappingJackson2HttpMessageConverter를 새롭게 등록하는 방법을 찾아보도록 하자.

JSON 형식의 요청 데이터를 자바의 커맨드 객체로 변환하려면 커맨드 객체에 @ResponseBody 어노테이션을 붙인다.
일반적으로 POST 방식은 쿼리 문자열(URL 뒤에 직접 패러미터를 입력하여 데이터를 전송하는 방식)을 사용한다.
여기서 JSON으로 데이터 전송 방식을 바꾸는 건데, 이러려면 넘기는 컨텐츠 타입을 바꿔줘야 한다. (application/x-www-form-urlencoded -> application/json으로)
이 경우 별도 프로그램을 이용해야 한다. 나중에 조사해보도록 하자.

JSON 형식의 데이터를 날짜 형식(LocalDateTime 혹은 Date)으로 변환하려면 별도 설정이 없을 경우 일정한 패턴을 따라야 한다. (yyyy-MM-ddTHH:mm:ss)
이 외의 다른 패턴을 가진 문자열을 LocalDateTime이나 Date 타입으로 변환하려면 @JsonFormat 어노테이션의 pattern 속성을 사용해야 한다.
예시 1)@JsonFormat(pattern = "yyyyMMddHHmmss")
예시 2)@JsonFormat(pattern = "yyyyMMdd HHmmss")
특정 패턴에 그치지 않고 해당 타입을 가지는 모든 속성에 적용하고 싶다면 스프링 MVC 설정을 추가해야 한다. 
extendMessageConverters 클래스의 deserializerByType().simpleDateFormat() 메소드를 사용하면 된다.
deserializerByType 메서드는 JSON 데이터를 LocalDateTime 타입으로 변환할 때 사용할 패턴을 지정하고, simpleDateFormat() 메소드는 JSON을 Date로, Date를 JSON으로 변환할 때 사용할 패턴을 지정한다.

@Valid 어노테이션을 사용하면 변환시킨 데이터를 "검증" 할 수 있다. "검증" 이 무엇인지는 나중에 조사해 본다.
HttpServletResponse를 사용할 경우, 결과가 정상이라면 JSON 데이터로 응답이 돌아오지만, 에러가 발생한다면 JSON이 아닌 HTML로 응답해 버린다.
이럴 경우 API를 사용할 때 JSON만 받지 않고 HTML 또한 받을 수 있기 떄문에 부담스러울 수 있다. 처리에 실패하여 에러가 발생했을 떄에도 JSON 데이터로 응답을 받는 편이 일관적이다.
두 경우 모두 JSON 응답을 전송하는 방법은 ResponseEntity 타입을 사용하는 것이다.
ResponseEntity를 사용하면 자신 내부의 body 메서드 패러미터로 지정한 객체를 JSON 데이터로 변환시킨다.
이렇게 이용하면 정상적으로 처리됐을 때의 객체를 body를 써서 JSON으로, 중간에 에러가 나면 에러 관련 객체를 body를 써서 JSON으로 변환시킬 수 있을 것이다.
이후 ResponseEntity의 .status 메서드를 함꼐 이용하여 상태 코드와 JSON 결과를 전송하는 방식으로 처리할 수 있다.
코드 모양새 정리 : ResponseEntity.status(상태코드).body(JSON으로 변환할 객체)
status 메서드에 사용할 상태 코드를 정의해둔 게 없다면 디폴트로 사용할 수 있는 물건들도 있다. 목록은 아래와 같다.
A. noContent() : 204 에러
B. badRequest() : 400 에러
C. notFound() : 404 에러

한 메서드에서 요청 결과가 정상일 때 / 에러가 발생했을 때 모두 ResponseEntity를 사용한다면 코드가 중복될 수 있다.
이럴 경우 @ExceptionHandler 어노테이션으로 에러 응답을 처리하도록 하면 중복을 없앨 수 있다.

여러 에러 관리를 하나로 모아 진행하고 싶다면, @RestControllerAdvice 어노테이션을 사용할 수도 있다.
위 어노테이션을 사용한 별도 클래스 내에 @ExceptionHandler 어노테이션을 적용한 에러 처리 메서드를 한 곳으로 모을 수 있다.

@Valid 어노테이션을 사용한 커맨드 객체가 "검증" 에 실패했을 경우 400 코드를 응답한다.
하지만 이 경우에도 HttpServletResponse를 이용하면 HTML 응답을 전송하게 된다. 
이를 해결하기 위해선(JSON으로 받고 싶다면) @Valid를 사용한 메서드의 패러미터로 Error 패러미터를 추가해 에러 응답을 직접 생성할 수 있다. 자세한 방법은 나중에 찾아보자.
그 외 Error 타입 패러미터를 붙이지 않았을 때 MethodArgumentNotValidException이 발생하므로, @ExceptionHandler 어노테이션에 이 익셉션을 집어넣어 에러 응답을 생성할 수도 있다고 한다.

# 프로필과 프로퍼티 파일 (440페이지 ~ 450페이지) 진행 중

개발 중에는 실제 서비스 떄 사용할 DB를 이용할 수 없다. 개발 중에는 개발용 DB를 따로 사용하거나 PC에 DB를 직접 설치해야 한다.
실제 서비스 환경에서는 웹 서버와 DB 서버가 서로 다른 장비에 설치된 경우도 많다.
즉, 개발을 완료한 어플리케이션을 실제 서버에 배포하려면 실제 서비스에 맞는 JDBC 연결 정보를 사용해야 한다.
이러한 분리된 환경에서의 실수를 방지하기 위해, 처음부터 개발 목적 설정과 실 서비스 목적 설정을 구분하여 작성할 수 있으며, 이를 위한 스프링 기능이 "프로필(profile)" 이다.

스프링 컨테이너 단계에서, 사용할 프로필을 선택해 그 내부의 설정으로 컨테이너를 초기화시킬 수 있다.
@Configuration 어노테이션을 사용 중인 클래스에서 @Profile 어노테이션을 사용해 프로필과 그 이름을 지정할 수 있다.
이렇게 지정하면 활성화시킨 프로필의 bean 객체 내용물로 선택하여 초기화시킬 수 있다.
특정 프로필을 선택하려면 context.getEnvironment().setActiveProfiles("프로필명") 메서드를 사용하면 된다.
혹은 java -Dspring.profiles.active=프로필명 명령을 이용해 시스템 프로퍼티에 사용할 프로필 값을 지정해도 된다.
그 외에도 OS의 환경변수에 spring.profiles.active 환경 변수를 사용할 수도 있다. 각각의 방법들은 나중에 조사해본다.
@Configuration 어노테이션을 사용한 클래스에 프로필 설정들을 모아둘 수도 있다.

@Profile 어노테이션의 속성으로 ,를 이용해 여러 이름을 지정할 경우 각 이름들을 사용할 경우 해당 프로필을 적용시킬 수 있다.
예시) @Profile("real,test") - real, test 이름을 지정할 경우 해당 프로필이 활성화됨

@Profile 어노테이션의 속성으로 !프로필명을 사용할 경우, 해당 프로필명이 사용되지 않았을 때 사용한다는 의미를 줄 수도 있다.
예시) @Profile("!real") - real 프로필이 활성화되지 않았다면 활성화됨

웹 어플리케이션의 경우 시스템 프로퍼티, 환경변수 외에도 web.xml에서 spring.profiles.active 초기화 패러미터를 이용하면 프로필을 선택할 수 있다.

@Valud 어노테이션을 이용하면 외부 프로퍼티 파일을 통해 스프링 빈으 설정할 수 있다. 이건 나중에 더 찾아보자.

# 부록 A - 메이븐 기초 안내(452 페이지 ~ 465 페이지) : 우리는 그레이들을 사용할 것으로 알고 있어 패스한다.

# 부록 B - 스프링 부트 소개(466 페이지 ~ 475 페이지) 진행 중

스프링 MVC를 이용해 DB와 연동되는 웹 어플리케이션을 만들 때에도 많은 준비를 해야 한다. 대부분 각종 설정과 관련된 것들이다.
스프링 부트를 사용하면 이 노력을 줄일 수 있다. 스프링 부트를 사용하면 최소한의 작업으로 스프링 프로젝트, JSON API를 만들 수 있다. 내장 서버를 이용하므로 톰캣도 필요 없어진다. 모니터링 기능도 제공해준다.
스프링 이니셜라이저를 사용하면 간단하게 체크박스로 다양한 설정을 마친 프로젝트 파일을 생성시킬 수 있다.
파일 내 @SpringBootApplication이 중요하다. 다양한 설정을 자동으로 처리해주므로 개발자가 필요한 것만 추가로 골라서 설정할 수 있다.
그 외에 컴포넌트 스캔 기능도 활성화시켜준다. @Component, @Service, @Controller, @RestController 등 스캔 대상 어노테이션을 붙인 클래스들을 빈으로 자동 등록해준다.

스프링부트를 이용해 DB 연동 설정을 할 때에도 pom.xml 파일에 spring-boot-starter-jdbc와 mysql-connector-java 두 의존을 추가하면 된다.

그 외에도 MyBatis, JPA와 같은 DB연동, 타임리프나 JSP와 같은 뷰 구현기술 연동, 톰캣이나 제티 같은 서버 연동 등 다양한 기본 설정을 제공해주고 있다.

# 부록 C - 타임리프 연동(476페이지 ~ ) : 우리는 타임리프 안 쓸 것 같으므로 패스한다.


