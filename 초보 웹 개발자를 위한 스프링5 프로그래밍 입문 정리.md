공부 방법을 변경하게 되었다.
책 속 코드나 용어를 전부 하나하나 분석하고 정리하는 방향에서, 책에 등장하는 용어나 기법에 대해 간략히 정리하고 기억해둠으로써 책을 빠르게 소화하는 방향으로 바꾸었다.
이는 추후 프로젝트를 시작하게 되었을 때 기억하고 있는 다양한 기법이나 패턴을 떠올릴 수 있게 되는 것에 더욱 힘을 주고 상세한 코드나 기술에 대한 건 프로젝트 중에 직접 체험해가며 실력을 키우는 것이 더욱 효율적이라 판단되었기 때문이다.

# 컴포넌트 스캔(130페이지 ~ 140페이지)

스프링에서 특정 클래스에 이름을 붙여 빈 객체로 등록해주는 기능을 컴포넌트라고 한다.

@Component 어노테이션을 사용하면 특정한 이름, 혹은 본래 클래스 이름(첫 글자만 소문자화시킨)의 빈 객체를 생성할 수 있다.
그리고 @ComponentScan 어노테이션을 사용해, 위 @Component로 등록한 클래스 객체를 Bean 객체로 등록시킨다.

이 과정을 거치면 @Component 어노테이션을 통해 빈 이름을 지정하게 되었으므로 기존의 getBean 메소드에서 이름을 지정할 필요가 없어진다.
그 외 특정 속성을 사용하여 빈 객체 자동 생성 대상을 제외하는 등의 기능이 가능하다.

@Component 어노테이션 외에도 @Controller, @Service, @Repository, @Aspect, @Configuration 등 어노테이션도 역할은 다르지만 같은 빈 검색&등록 기능을 수행한다.
빈 객체 자동 등록 기능을 사용할 때에는 빈 이름 관련, 수동 등록과 관련하여 충돌이 발생할 수 있으니 주의해야 한다.

# 빈 객체의 라이프사이클과 범위(141페이지 ~ 151페이지)

어노테이션을 통해 생성하는 빈 객체들은 개발자의 코드 밖에 있는 저장소인 스프링 컨테이너에 저장된다.
스프링 컨테이너는 필요시 초기화되고 사용을 완료하면 종료되는 사이클을 가지고 있다.
AnnotationConfigApplicationContext 객체를 생성하는 순간이 컨테이너가 초기화되는 순간이다. 이 때 빈 객체가 생성되고, 각 빈끼리의 의존 주입이 실행된다.
컨테이너가 초기화되어 있는 동안, AnnotationConfigApplicationContext 객체의 getBean() 메소드 등을 사용하여 빈 객체에 접근한다.
컨테이너 사용을 마친 후 AnnotationConfigApplicationContext 객체의 close() 메소드를 사용하여 컨테이너를 종료한다. 이 때 컨테이너 내부의 빈 객체가 소멸된다.
빈 객체를 초기화하고 소멸시키는 기능을 담당하는 각 인터페이스가 있는데, 이를 사용할 빈 객체에서 구현한 후 초기화/소멸 시 호출되는 메소드를 사용하면 초기화/소멸 시에 작동시킬 기능을 작성할 수 있다.
직접 생성한 클래스가 아니라 위 인터페이스를 구현할 수 없는 상황이라 해도, @Bean 어노테이션의 initMethod, destroyMethod 속성을 사용하면 초기화/소멸 시 실행시킬 메소드를 작성/지정할 수 있다.
빈 객체는 기본적으로 싱글톤(singleton) 범위로 하나의 객체만 생성되어 공유된다. 같은 이름의 다른 빈 객체를 생성할 수도 있지만 사용 빈도는 낮다.

# AOP 패턴에 대하여 (152 ~ 177페이지)

특정 기능이나 클래스를 여러가지 개발하다 보면 공통적으로 사용되는 코드가 생기기 마련이다.
예시 1) DBMS 사용 시, 자바 코드상으로 DB로 데이터를 전송하기 위해 자바와 DB를 중개해주는 객체를 생성하고 close 하는 과정
예시 2) 특정 기능들에 해당 기능이 1회 완료될 때까지 걸리는 시간의 로그를 남기는 과정

이러한 코드들을 매번 작성하는 것보다 별도로 나누어서 관리할 수 있게 된다면 해당 코드들을 반복해서 작성할 필요가 없을 것이다.
또한 반복되는 코드를 부품화하여 사용할 수 있기 때문에 핵심 기능의 개발에만 집중할 수 있을 것이다.

이렇게 여러 클래스를 개발할 때 '공통 기능' 과 '핵심 로직' 을 별도로 분리해서 개발/관리하는 패턴을 AOP(Aspect-Oriented Programming / 관점 지향 프로그래밍)라고 한다.
반복적으로 사용하게 될 공통 기능을 구상하게 되거나, 기존의 공통 코드를 간소화하여 코드를 경량화시키는 데 큰 도움이 될 것이다. 기억해 두자.

위의 AOP 패턴을 구현할 때 필요한 것이 프록시 객체이다. 공통 기능과 핵심 로직을 구분했을 때, 공통 기능을 담당하는 코드만 가지고 핵심 로직은 메소드는 다른 객체들 가져와 실행하는 객체가 프록시 객체이다.
프록시 객체의 핵심은 공통 기능만 구현하는 것이다. 핵심 로직은 외부 객체를 사용한다.

AOP 패턴을 사용할 때 사용하는 주요 용어는 아래와 같다.
1. Advice : 핵심 로직 외에 적용할 공통 기능을 가리킨다.
2. Joinpoint : Advice, 즉 핵심 로직을 적용할 지점을 정의한다. 가장 대표적인 경우는 메서드 호출이다.
3. Pointcut : Joinpoint의 보다 일반적인 범주를 지정한다.
4. Weaving : 공통 기능인 Advice을 적용 시점인 Pointcut에 실제 적용하는 작업이다.
5. Aspect : 위의 Advice부터 Point까지 작성한, 목적과 작동이 확정된 공통 기능의 단위이다.

스프링에서 널리 사용되는 공통 기능(Advice)는 메서드 실행 전/후, 예외 발생 시 작동할 기능(Around Advice)이다.
스프링에서는 어노테이션을 통해 AOP 패턴을 담당하는 위 기능들을 지정한다. @Aspect, @Around, @Pointcut 등의 어노테이션을 사용한다. 그 외의 AOP 관련 어노테이션들은 추후 공부하는 것으로.

# DB 연동에 대하여(178페이지 ~ 231P)

## JdbcTemplate 클래스
JDBC를 사용할 경우 실질적인 프로젝트의 기능과 관계가 없지만 구조적으로 반복되는 코드가 생기게 된다. 스프링에서 제공하는 JdbcTemplate 클래스를 활용하면 이 반복을 줄일 수 있고, 편하게 쿼리를 실행시킬 수 있다.

## 트랜잭션
스프링을 사용하면 트랜잭션 관리 또한 쉬워진다. 트랜잭션이란 "시작부터 끝까지 온전히 성공해야 하는 논리적으로 연결된 하나의 작동" 을 전제로 하는 작업이다.
트랜잭션의 결과는 성공(시작부터 끝까지 온전히 작동함) 혹은 그렇지 못한 상태일 것이다.
이 경우 트랜잭션이 성공했다면 결과를 확정짓겠지만, 실패했다면(온전히 작동하지 않았다면) 트랜잭션 시작 이전으로 모든 상태를 되돌려야 한다.
결과의 확정을 커밋(Commit), 상태를 되돌리는 것을 롤백(Rollback)이라고 한다.
스프링에서 @Transaction 어노테이션을 사용하면 트랜잭션 범위를 쉽게 지정하여 실행/관리할 수 있다. 어노테이션 사용법은 나중에 조사한다.
@Transaction 어노테이션은 트랜잭션을 실행해도 시작과 결과(커밋or롤백) 여부를 확인할 수 없다. 이를 확인하려면 스프링을 통해 로그 메시지를 봐야 한다.
@Transaction 어노테이션은 상기한 AOP 패턴을 사용하며, 프록시 객체를 통해 기능을 구현해 두었다고 한다.
@Transaction 어노테이션을 적용한 객체의 메서드에서 Runtime Exception이 발생할 경우에는 자동으로 트랜잭션이 롤백된다.

## 커넥션 풀
자바에서 DB로 한 번 연결하는 과정은 컴퓨터 입장에서 꽤 큰 시간을 소모한다.
그래서 매번 DB로 데이터를 전송하는 시점에 DB와 연결을 하게 된다면 비효율적이게 된다.
이를 위해 일정 수의 연결을 미리 만들어 둔 뒤 생성/소멸시키지 않고 활성/유휴만 시키는 패턴을 커넥션 풀이라고 한다.
Tomcat JDBC 모듈의 DataSource 클래스가 이러한 커넥션 풀 기능을 지원하고 있다.

# 스프링 MVC에 대하여 (232페이지 ~ 248페이지)

스프링은 웹 MVC 프레임워크 또한 지원한다.
스프링 MVC를 실행하려면 자바 파일을 통한 구성 요소 설정이 필요하다. 본래는 수십 줄의 코드를 작성해야 하지만, @EnableWebMvc 어노테이션을 사용하면 내부적으로 설정을 마칠 수 있다고 한다.
또한 web.xml 파일에 DispatcherServlet을 설정해야 한다.
그 외 웹 어플리케이션 설정(톰캣 등) 또한 나중에 조사한다.

책에 등장하는 각종 어노테이션은 명칭만 정리하며, 정확한 기능 및 사용법은 추후 조사한다.
1. @GetMapping 어노테이션
2. @RequestParam 어노테이션
3. 

## MVC 중 컨트롤러 : 컨트롤러는 사용자로부터 특정한 입력이나 명령을 해석 및 분류하여, 나머지 Model과 View로 연결시키는 기능을 수행한다.
## MVC 중 뷰 : 뷰는 사용자가 실제 접하게 되는 화면을 가리킨다. 초기 화면부터 시작해서 사용자가 요청한 내용을 처리한 후 보여야 할 결과나 데이터를 화면에 출력시킨다.
## MVC 중 모델 : 모델은 사용자가 요청한 명령이나 데이터 등을 실제로 처리하는 부분이다. 사용자에게 드러나지는 않지만 실제 필요한 데이터의 처리나 DB 연동 등의 작업은 모델에서 실행된다.

스프링 MVC 프레임워크를 사용하면 모델에서 처리한 데이터를 뷰(실제 화면 단 - 즉 웹페이지 - java가 아닌 jsp 등 페이지 파일)에서도 접근할 수 있다.

# 스프링 MVC 프레임워크의 동작 방식에 대하여(249페이지 ~ )
